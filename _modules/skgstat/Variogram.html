
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>skgstat.Variogram &#8212; SciKit GStat 0.6.4 documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../../index.html">
<p class="title">SciKit GStat</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../getting_started.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../userguide/userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../tutorials/tutorials.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../technical/technical.html">
  Technical Notes
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../reference/reference.html">
  Code Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../changelog.html">
  Changelog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference external nav-link" href="https://mmaelicke.github.io/scikit-gstat/SciKitGStat.pdf">
  PDF
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/mmaelicke/scikit-gstat" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for skgstat.Variogram</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Variogram class</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span><span class="p">,</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">OptimizeWarning</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">sklearn.isotonic</span> <span class="kn">import</span> <span class="n">IsotonicRegression</span>

<span class="kn">from</span> <span class="nn">skgstat</span> <span class="kn">import</span> <span class="n">estimators</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">binning</span>
<span class="kn">from</span> <span class="nn">skgstat</span> <span class="kn">import</span> <span class="n">plotting</span>
<span class="kn">from</span> <span class="nn">skgstat.util</span> <span class="kn">import</span> <span class="n">shannon_entropy</span>
<span class="kn">from</span> <span class="nn">.MetricSpace</span> <span class="kn">import</span> <span class="n">MetricSpace</span><span class="p">,</span> <span class="n">ProbabalisticMetricSpace</span>
<span class="kn">from</span> <span class="nn">skgstat.interfaces.gstools</span> <span class="kn">import</span> <span class="n">skgstat_to_gstools</span><span class="p">,</span> <span class="n">skgstat_to_krige</span>


<div class="viewcode-block" id="Variogram"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram">[docs]</a><span class="k">class</span> <span class="nc">Variogram</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variogram Class</span>

<span class="sd">    Calculates a variogram of the separating distances in the given</span>
<span class="sd">    coordinates and relates them to one of the semi-variance measures of</span>
<span class="sd">    the given dependent values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Variogram.__init__"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">estimator</span><span class="o">=</span><span class="s1">&#39;matheron&#39;</span><span class="p">,</span>
                 <span class="n">model</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                 <span class="n">dist_func</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                 <span class="n">bin_func</span><span class="o">=</span><span class="s1">&#39;even&#39;</span><span class="p">,</span>
                 <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fit_method</span><span class="o">=</span><span class="s1">&#39;trf&#39;</span><span class="p">,</span>
                 <span class="n">fit_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">use_nugget</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">maxlag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_lags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Variogram Class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray, MetricSpace</span>
<span class="sd">            .. versionchanged:: 0.5.0</span>
<span class="sd">                now accepts MetricSpace</span>
<span class="sd">            Array of shape (m, n). Will be used as m observation points of</span>
<span class="sd">            n-dimensions. This variogram can be calculated on 1 - n</span>
<span class="sd">            dimensional coordinates. In case a 1-dimensional array is passed,</span>
<span class="sd">            a second array of same length containing only zeros will be</span>
<span class="sd">            stacked to the passed one.</span>
<span class="sd">            For very large datasets, you can set maxlag to only calculate</span>
<span class="sd">            distances within the maximum lag in a sparse matrix.</span>
<span class="sd">            Alternatively you can supply a MetricSpace (optionally with a</span>
<span class="sd">            `max_dist` set for the same effect). This is useful if you&#39;re</span>
<span class="sd">            creating many different variograms for different measured</span>
<span class="sd">            parameters that are all measured at the same set of coordinates,</span>
<span class="sd">            as distances will only be calculated once, instead of once per</span>
<span class="sd">            variogram.</span>
<span class="sd">        values : numpy.ndarray</span>
<span class="sd">            Array of values observed at the given coordinates. The length of</span>
<span class="sd">            the values array has to match the m dimension of the coordinates</span>
<span class="sd">            array. Will be used to calculate the dependent variable of the</span>
<span class="sd">            variogram.</span>
<span class="sd">        estimator : str, callable</span>
<span class="sd">            String identifying the semi-variance estimator to be used.</span>
<span class="sd">            Defaults to the Matheron estimator. Possible values are:</span>

<span class="sd">              * matheron        [Matheron, default]</span>
<span class="sd">              * cressie         [Cressie-Hawkins]</span>
<span class="sd">              * dowd            [Dowd-Estimator]</span>
<span class="sd">              * genton          [Genton]</span>
<span class="sd">              * minmax          [MinMax Scaler]</span>
<span class="sd">              * entropy         [Shannon Entropy]</span>

<span class="sd">            If a callable is passed, it has to accept an array of absoulte</span>
<span class="sd">            differences, aligned to the 1D distance matrix (flattened upper</span>
<span class="sd">            triangle) and return a scalar, that converges towards small</span>
<span class="sd">            values for similarity (high covariance).</span>
<span class="sd">        model : str</span>
<span class="sd">            String identifying the theoretical variogram function to be used</span>
<span class="sd">            to describe the experimental variogram. Can be one of:</span>

<span class="sd">              * spherical       [Spherical, default]</span>
<span class="sd">              * exponential     [Exponential]</span>
<span class="sd">              * gaussian        [Gaussian]</span>
<span class="sd">              * cubic           [Cubic]</span>
<span class="sd">              * stable          [Stable model]</span>
<span class="sd">              * matern          [Matérn model]</span>
<span class="sd">              * nugget          [nugget effect variogram]</span>

<span class="sd">        dist_func : str</span>
<span class="sd">            String identifying the distance function. Defaults to</span>
<span class="sd">            &#39;euclidean&#39;. Can be any metric accepted by</span>
<span class="sd">            scipy.spatial.distance.pdist. Additional parameters are not (yet)</span>
<span class="sd">            passed through to pdist. These are accepted by pdist for some of</span>
<span class="sd">            the metrics. In these cases the default values are used.</span>
<span class="sd">        bin_func : str</span>
<span class="sd">            .. versionchanged:: 0.3.8</span>
<span class="sd">                added &#39;fd&#39;, &#39;sturges&#39;, &#39;scott&#39;, &#39;sqrt&#39;, &#39;doane&#39;</span>
<span class="sd">            .. versionchanged:: 0.3.9</span>
<span class="sd">                added &#39;kmeans&#39;, &#39;ward&#39;</span>

<span class="sd">            String identifying the binning function used to find lag class</span>
<span class="sd">            edges. All methods calculate bin edges on the interval [0, maxlag[.</span>
<span class="sd">            Possible values are:</span>

<span class="sd">                * `&#39;even&#39;` (default) finds `n_lags` same width bins</span>
<span class="sd">                * `&#39;uniform&#39;` forms `n_lags` bins of same data count</span>
<span class="sd">                * `&#39;fd&#39;` applies Freedman-Diaconis estimator to find `n_lags`</span>
<span class="sd">                * `&#39;sturges&#39;` applies Sturge&#39;s rule to find `n_lags`.</span>
<span class="sd">                * `&#39;scott&#39;` applies Scott&#39;s rule to find `n_lags`</span>
<span class="sd">                * `&#39;doane&#39;` applies Doane&#39;s extension to Sturge&#39;s rule</span>
<span class="sd">                  to find `n_lags`</span>
<span class="sd">                * `&#39;sqrt&#39;` uses the square-root of</span>
<span class="sd">                  :func:`distance &lt;skgstat.Variogram.distance&gt;`</span>
<span class="sd">                  as `n_lags`.</span>
<span class="sd">                * `&#39;kmeans&#39;` uses KMeans clustering to well supported bins</span>
<span class="sd">                * `&#39;ward&#39;` uses hierachical clustering to find</span>
<span class="sd">                  minimum-variance clusters.</span>

<span class="sd">            More details are given in the documentation for</span>
<span class="sd">            :func:`set_bin_func &lt;skgstat.Variogram.set_bin_func&gt;`.</span>

<span class="sd">        normalize : bool</span>
<span class="sd">            Defaults to False. If True, the independent and dependent</span>
<span class="sd">            variable will be normalized to the range [0,1].</span>
<span class="sd">        fit_method : str</span>
<span class="sd">            .. versionchanged:: 0.3.10</span>
<span class="sd">                Added &#39;ml&#39; and &#39;custom&#39;</span>

<span class="sd">            String identifying the method to be used for fitting the</span>
<span class="sd">            theoretical variogram function to the experimental. More info is</span>
<span class="sd">            given in the Variogram.fit docs. Can be one of:</span>

<span class="sd">                * &#39;lm&#39;: Levenberg-Marquardt algorithm for unconstrained</span>
<span class="sd">                  problems. This is the faster algorithm, yet is the fitting of</span>
<span class="sd">                  a variogram not unconstrianed.</span>
<span class="sd">                * &#39;trf&#39;: Trust Region Reflective function for non-linear</span>
<span class="sd">                  constrained problems. The class will set the boundaries</span>
<span class="sd">                  itself. This is the default function.</span>
<span class="sd">                * &#39;ml&#39;: Maximum-Likelihood estimation. With the current</span>
<span class="sd">                  implementation only the Nelder-Mead solver for</span>
<span class="sd">                  unconstrained problems is implemented. This will estimate</span>
<span class="sd">                  the variogram parameters from a Gaussian parameter space</span>
<span class="sd">                  by minimizing the negative log-likelihood.</span>
<span class="sd">                * &#39;manual&#39;: Manual fitting. You can set the range, sill and</span>
<span class="sd">                  nugget either directly to the</span>
<span class="sd">                  :func:`fit &lt;skgstat.Variogram.fit&gt;` function, or as</span>
<span class="sd">                  `fit_` prefixed keyword arguments on Variogram instantiation.</span>

<span class="sd">        fit_sigma : numpy.ndarray, str</span>
<span class="sd">            Defaults to None. The sigma is used as measure of uncertainty</span>
<span class="sd">            during variogram fit. If fit_sigma is an array, it has to hold</span>
<span class="sd">            n_lags elements, giving the uncertainty for all lags classes. If</span>
<span class="sd">            fit_sigma is None (default), it will give no weight to any lag.</span>
<span class="sd">            Higher values indicate higher uncertainty and will lower the</span>
<span class="sd">            influcence of the corresponding lag class for the fit.</span>
<span class="sd">            If fit_sigma is a string, a pre-defined function of separating</span>
<span class="sd">            distance will be used to fill the array. Can be one of:</span>

<span class="sd">                * &#39;linear&#39;: Linear loss with distance. Small bins will have</span>
<span class="sd">                  higher impact.</span>
<span class="sd">                * &#39;exp&#39;: The weights decrease by a e-function of distance</span>
<span class="sd">                * &#39;sqrt&#39;: The weights decrease by the squareroot of distance</span>
<span class="sd">                * &#39;sq&#39;: The weights decrease by the squared distance.</span>

<span class="sd">            More info is given in the Variogram.fit_sigma documentation.</span>
<span class="sd">        use_nugget : bool</span>
<span class="sd">            Defaults to False. If True, a nugget effet will be added to all</span>
<span class="sd">            Variogram.models as a third (or fourth) fitting parameter. A</span>
<span class="sd">            nugget is essentially the y-axis interception of the theoretical</span>
<span class="sd">            variogram function.</span>
<span class="sd">        maxlag : float, str</span>
<span class="sd">            Can specify the maximum lag distance directly by giving a value</span>
<span class="sd">            larger than 1. The binning function will not find any lag class</span>
<span class="sd">            with an edge larger than maxlag. If 0 &lt; maxlag &lt; 1, then maxlag</span>
<span class="sd">            is relative and maxlag * max(Variogram.distance) will be used.</span>
<span class="sd">            In case maxlag is a string it has to be one of &#39;median&#39;, &#39;mean&#39;.</span>
<span class="sd">            Then the median or mean of all Variogram.distance will be used.</span>
<span class="sd">            Note maxlag=0.5 will use half the maximum separating distance,</span>
<span class="sd">            this is not the same as &#39;median&#39;, which is the median of all</span>
<span class="sd">            separating distances</span>
<span class="sd">        samples : float, int</span>
<span class="sd">            If set to a non-None value point pairs are sampled</span>
<span class="sd">            randomly. Two random subset of all points are chosen, and</span>
<span class="sd">            the distance matrix is calculated only between these two</span>
<span class="sd">            subsets. The size of each subset is set by `samples`: if &lt;</span>
<span class="sd">            1 it specifies a fraction of all points, if &gt;= 1 it</span>
<span class="sd">            specifies the number of points in each subset.</span>
<span class="sd">        n_lags : int</span>
<span class="sd">            Specify the number of lag classes to be defined by the binning</span>
<span class="sd">            function.</span>
<span class="sd">        verbose : bool</span>
<span class="sd">            Set the Verbosity of the class. Not Implemented yet.</span>

<span class="sd">        Keyword Arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        entropy_bins : int, str</span>
<span class="sd">            .. versionadded:: 0.3.7</span>

<span class="sd">            If the `estimator &lt;skgstat.Variogram.estimator&gt;` is set to</span>
<span class="sd">            `&#39;entropy&#39;` this argument sets the number of bins, that should be</span>
<span class="sd">            used for histogram calculation.</span>
<span class="sd">        percentile : int</span>
<span class="sd">            .. versionadded:: 0.3.7</span>

<span class="sd">            If the `estimator &lt;skgstat.Variogram.estimator&gt;` is set to</span>
<span class="sd">            `&#39;entropy&#39;` this argument sets the percentile to be used.</span>
<span class="sd">        binning_random_state : int, None</span>
<span class="sd">            .. versionadded:: 0.3.9</span>

<span class="sd">            If :func:`bin_func &lt;skgstat.Variogram.set_bin_func&gt;` is `&#39;kmeans&#39;`</span>
<span class="sd">            this can overwrite the seed for the initial guess of the cluster</span>
<span class="sd">            centroids. Note, that K-Means is not deterministic and is therefore</span>
<span class="sd">            seeded to 42 here. You can pass `None` to disable this behavior,</span>
<span class="sd">            but use it with care, as you will get different results.</span>
<span class="sd">        binning_agg_func : str</span>
<span class="sd">            .. versionadded:: 0.3.10</span>

<span class="sd">            If :func:`bin_func &lt;skgstat.Variogram.set_bin_func&gt;` is `&#39;ward&#39;`</span>
<span class="sd">            this keyword argument can switch from default mean aggregation to</span>
<span class="sd">            median aggregation for calculating the cluster centroids.</span>
<span class="sd">        obs_sigma : int, float</span>
<span class="sd">            .. versionadded:: 0.6.0</span>

<span class="sd">            If set, the Variogram will use this sigma as the standard deviation</span>
<span class="sd">            of the observations passed as values. Using a MonteCarlo simulation</span>
<span class="sd">            the uncertainties are propagated into the experimental variogram.</span>
<span class="sd">            If present, the plot will indicate the confidence interval as</span>
<span class="sd">            error bars around the experimental variogram.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Before we do anything else, make kwargs available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># handle the coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_1d</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">MetricSpace</span><span class="p">):</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

            <span class="c1"># handle 1D coords</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                    <span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span>
                <span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_1d</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># handle maxlag for MetricSpace</span>
            <span class="k">if</span> <span class="n">maxlag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxlag</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxlag</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_maxlag</span> <span class="o">=</span> <span class="n">maxlag</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_maxlag</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="n">MetricSpace</span><span class="p">(</span>
                    <span class="n">coordinates</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">dist_func</span><span class="p">,</span>
                    <span class="n">_maxlag</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="n">ProbabalisticMetricSpace</span><span class="p">(</span>
                    <span class="n">coordinates</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">dist_func</span><span class="p">,</span> <span class="n">_maxlag</span><span class="p">,</span>
                    <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
                    <span class="n">rnd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;binning_random_state&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dist_func</span> <span class="o">!=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">dist_metric</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">((</span>
                <span class="s2">&quot;Distance metric of variogram differs &quot;</span>
                <span class="s2">&quot;from distance metric of coordinates&quot;</span>
            <span class="p">))</span>

        <span class="c1"># Set coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">coordinates</span>

        <span class="c1"># pairwise differences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># set values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># calc_diff = False here, because it will be calculated by fit() later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">calc_diff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># lags and max lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags_passed_value</span> <span class="o">=</span> <span class="n">n_lags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_lags</span> <span class="o">=</span> <span class="n">n_lags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxlag</span> <span class="o">=</span> <span class="n">maxlag</span>

        <span class="c1"># harmonize model placeholder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># estimator can be a function or a string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_estimator</span><span class="p">(</span><span class="n">estimator_name</span><span class="o">=</span><span class="n">estimator</span><span class="p">)</span>

        <span class="c1"># the binning settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bin_func</span><span class="p">(</span><span class="n">bin_func</span><span class="o">=</span><span class="n">bin_func</span><span class="p">)</span>

        <span class="c1"># Needed for harmonized models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># model can be a function or a string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># specify if the lag should be given absolute or relative to the maxlag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">normalize</span>

        <span class="c1"># set if nugget effect shall be used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_nugget</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span> <span class="o">=</span> <span class="n">use_nugget</span>

        <span class="c1"># set the fitting method and sigma array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_method</span> <span class="o">=</span> <span class="n">fit_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span> <span class="o">=</span> <span class="n">fit_sigma</span>

        <span class="c1"># set attributes to be filled during calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># settings, not reachable by init (not yet)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_experimental</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># do the preprocessing and fitting upon initialization</span>
        <span class="c1"># Note that fit() calls preprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># finally check if any of the uncertainty propagation kwargs are set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_experimental_conf_interval</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_conf_interval</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;obs_sigma&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_obs_sigma</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coordinates property</span>

<span class="sd">        Array of observation locations the variogram is build for. This</span>
<span class="sd">        property has no setter. If you want to change the coordinates,</span>
<span class="sd">        use a new Variogram instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coordinates : numpy.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metric_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.5.6</span>
<span class="sd">        </span>
<span class="sd">        :class:`MetricSpace &lt;skgstat.MetricSpace&gt;` representation of the</span>
<span class="sd">        input coordinates. A :class:`MetricSpace &lt;skgstat.MetricSpace&gt;`</span>
<span class="sd">        can be used to pass pre-calculated coordinates to other</span>
<span class="sd">        :class:`Variogram &lt;skgstat.Variogram&gt;` instances.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metric_space : skgstat.MetricSpace</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.coordinates : coordinate representation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span>

    <span class="nd">@metric_space</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">metric_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;MetricSpace is read-only.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input coordinates dimensionality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_1d</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Values property</span>

<span class="sd">        Array of observations, the variogram is build for. The setter of this</span>
<span class="sd">        property utilizes the Variogram.set_values function for setting new</span>
<span class="sd">        arrays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.set_values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

    <span class="nd">@values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value matrix</span>

<span class="sd">        Returns a matrix of pairwise differences in absolute values. The</span>
<span class="sd">        matrix will have the shape (m, m) with m = len(Variogram.values).</span>
<span class="sd">        Note that Variogram.values holds the values themselves, while the</span>
<span class="sd">        value_matrix consists of their pairwise differences.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : numpy.matrix</span>
<span class="sd">            Matrix of pairwise absolute differences of the values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram._diff</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">squareform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.set_values"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.set_values">[docs]</a>    <span class="k">def</span> <span class="nf">set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">calc_diff</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set new values</span>

<span class="sd">        Will set the passed array as new value array. This array has to be of</span>
<span class="sd">        same length as the first axis of the coordinates array. The Variogram</span>
<span class="sd">        class does only accept one dimensional arrays.</span>
<span class="sd">        On success all fitting parameters are deleted and the pairwise</span>
<span class="sd">        differences are recalculated.</span>
<span class="sd">        Raises :py:class:`ValueError`s on shape mismatches and a Warning</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : raised if the values array shape does not match the</span>
<span class="sd">            coordinates array, or more than one dimension given</span>
<span class="sd">        Warning : raised if all input values are the same</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check dimensions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The length of the values array has to match&#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;the length of coordinates&#39;</span><span class="p">)</span>

        <span class="c1"># use an array</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The values shall be a 1-D array.&#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;Multi-dimensional values not supported yet.&#39;</span><span class="p">)</span>

        <span class="c1"># check if all input values are the same</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_y</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;All input values are the same.&#39;</span><span class="p">)</span>

        <span class="c1"># reset fitting parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set new values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># recalculate the pairwise differences</span>
        <span class="k">if</span> <span class="n">calc_diff</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_diff</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Binning function</span>

<span class="sd">        Returns an instance of the function used for binning the separating</span>
<span class="sd">        distances into the given amount of bins. Both functions use the same</span>
<span class="sd">        signature of func(distances, n, maxlag).</span>

<span class="sd">        The setter of this property utilizes the Variogram.set_bin_func to</span>
<span class="sd">        set a new function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        binning_function : function</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.set_bin_func</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span>

    <span class="nd">@bin_func</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bin_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bin_func</span><span class="p">(</span><span class="n">bin_func</span><span class="o">=</span><span class="n">bin_func</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.set_bin_func"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.set_bin_func">[docs]</a>    <span class="k">def</span> <span class="nf">set_bin_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_func</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set binning function</span>

<span class="sd">        Sets a new binning function to be used. The new binning method is set</span>
<span class="sd">        by a string identifying the new function to be used. Can be one of:</span>
<span class="sd">        [&#39;even&#39;, &#39;uniform&#39;, &#39;fd&#39;, &#39;sturges&#39;, &#39;scott&#39;, &#39;sqrt&#39;, &#39;doane&#39;].</span>
<span class="sd">        If the number of lag classes should be estimated automatically, it is</span>
<span class="sd">        recommended to use &#39; sturges&#39; for small, normal distributed locations</span>
<span class="sd">        and &#39;fd&#39; or &#39;scott&#39; for large datasets, where &#39;fd&#39; is more robust to</span>
<span class="sd">        outliers. &#39;sqrt&#39; is by far the fastest estimator. &#39;doane&#39; is an</span>
<span class="sd">        extension of Sturge&#39;s rule for non-normal distributed data.</span>

<span class="sd">        .. versionchanged:: 0.3.8</span>
<span class="sd">            added &#39;fd&#39;, &#39;sturges&#39;, &#39;scott&#39;, &#39;sqrt&#39;, &#39;doane&#39;</span>

<span class="sd">        .. versionchanged:: 0.3.9</span>
<span class="sd">            added &#39;kmeans&#39;, &#39;ward&#39;</span>

<span class="sd">        .. versionchanged:: 0.4.0</span>
<span class="sd">            added &#39;stable_entropy&#39;</span>

<span class="sd">        .. versionchanged:: 0.4.1</span>
<span class="sd">            refactored local wrapper function definition. The wrapper to</span>
<span class="sd">            pass kwargs to the binning functions is now implemented as</span>
<span class="sd">            a instance method, to make it pickleable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_func : str</span>
<span class="sd">            Can be one of:</span>

<span class="sd">                * &#39;even&#39;</span>
<span class="sd">                * &#39;uniform&#39;</span>
<span class="sd">                * &#39;fd&#39;</span>
<span class="sd">                * &#39;sturges&#39;</span>
<span class="sd">                * &#39;scott&#39;</span>
<span class="sd">                * &#39;sqrt&#39;</span>
<span class="sd">                * &#39;doane&#39;</span>
<span class="sd">                * &#39;kmeans&#39;</span>
<span class="sd">                * &#39;ward&#39;</span>
<span class="sd">                * &#39;stable_entropy&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **`&#39;even&#39;`**: Use skgstat.binning.even_width_lags for using</span>
<span class="sd">        n_lags lags of equal width up to maxlag.</span>

<span class="sd">        **`&#39;uniform&#39;`**: Use skgstat.binning.uniform_count_lags for using</span>
<span class="sd">        n_lags lags up to maxlag in which the pairwise differences</span>
<span class="sd">        follow a uniform distribution.</span>

<span class="sd">        **`&#39;sturges&#39;`**: estimates the number of evenly distributed lag</span>
<span class="sd">        classes (n) by Sturges rule [101]_:</span>

<span class="sd">        .. math::</span>
<span class="sd">            n = log_2 n + 1</span>

<span class="sd">        **`&#39;scott&#39;`**: estimates the lag class widths (h) by</span>
<span class="sd">        Scott&#39;s rule [102]_:</span>

<span class="sd">        .. math::</span>
<span class="sd">            h = \sigma \frac{24 * \sqrt{\pi}}{n}^{\frac{1}{3}}</span>

<span class="sd">        **`&#39;sqrt&#39;`**: estimates the number of lags (n) by the suare-root:</span>

<span class="sd">        .. math::</span>
<span class="sd">            n = \sqrt{n}</span>

<span class="sd">        **`&#39;fd&#39;`**: estimates the lag class widths (h) using the</span>
<span class="sd">        Freedman Diaconis estimator [103]_:</span>

<span class="sd">        .. math::</span>
<span class="sd">            h = 2\frac{IQR}{n^{1/3}}</span>

<span class="sd">        **`&#39;doane&#39;`**: estimates the number of evenly distributed lag classes</span>
<span class="sd">        using Doane&#39;s extension to Sturge&#39;s rule [104]_:</span>

<span class="sd">        .. math::</span>
<span class="sd">            n = 1 + \log_{2}(s) + \log_2\left(1 + \frac{|g|}{k}\right)</span>
<span class="sd">            g = E\left[\left(\frac{x - \mu_g}{\sigma}\right)^3\right]</span>
<span class="sd">            k = \sqrt{\frac{6(s - 2)}{(s + 1)(s + 3)}}</span>

<span class="sd">        **`&#39;kmeans&#39;`**: This method will search for `n` clusters in the</span>
<span class="sd">        distance matrix. The cluster centroids are used to calculate the</span>
<span class="sd">        upper edges of the lag classes, by setting it to half of the distance</span>
<span class="sd">        between two neighboring clusters. Note: This does not necessarily</span>
<span class="sd">        result in even width bins.</span>

<span class="sd">        **`&#39;ward&#39;`** uses a hierachical culstering algorithm to iteratively</span>
<span class="sd">        merge pairs of clusters until there are only `n` remaining clusters.</span>
<span class="sd">        The merging is done by minimizing the variance for the merged cluster.</span>

<span class="sd">        **`&#39;stable_entropy&#39;`** will adjust `n` bin edges by minimizing the</span>
<span class="sd">        absolute differences between each lag&#39;s Shannon Entropy. This will</span>
<span class="sd">        lead to uneven bin widths. Each lag class value distribution will be</span>
<span class="sd">        of comparable intrinsic uncertainty from an information theoretic</span>
<span class="sd">        point of view, which makes the semi-variances quite comparable.</span>
<span class="sd">        However, it is not guaranteed, that the binning makes any sense</span>
<span class="sd">        from a geostatistical point of view, as the first lags might be way</span>
<span class="sd">        too wide.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.bin_func</span>
<span class="sd">        skgstat.binning.uniform_count_lags</span>
<span class="sd">        skgstat.binning.even_width_lags</span>
<span class="sd">        skgstat.binning.auto_derived_lags</span>
<span class="sd">        skgstat.binning.kmeans</span>
<span class="sd">        skgstat.binning.ward</span>
<span class="sd">        sklearn.cluster.KMeans</span>
<span class="sd">        sklearn.cluster.AgglomerativeClustering</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [101] Scott, D.W. (2009), Sturges&#39; rule. WIREs Comp Stat, 1:</span>
<span class="sd">            303-306. https://doi.org/10.1002/wics.35</span>
<span class="sd">        .. [102] Scott, D.W. (2010), Scott&#39;s rule. WIREs Comp Stat, 2:</span>
<span class="sd">            497-502. https://doi.org/10.1002/wics.103</span>
<span class="sd">        .. [103] Freedman, David, and Persi Diaconis  (1981), &quot;On the</span>
<span class="sd">            histogram as a density estimator: L 2 theory.&quot; Zeitschrift</span>
<span class="sd">            für Wahrscheinlichkeitstheorie und verwandte Gebiete 57.4:</span>
<span class="sd">            453-476.</span>
<span class="sd">        .. [104] Doane, D. P. (1976). Aesthetic frequency classifications.</span>
<span class="sd">            The American Statistician, 30(4), 181-183.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># handle strings</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">bin_func</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="c1"># switch the input</span>
            <span class="k">if</span> <span class="n">fname</span> <span class="o">==</span> <span class="s1">&#39;even&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">even_width_lags</span>

            <span class="k">elif</span> <span class="n">fname</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">uniform_count_lags</span>

            <span class="c1"># remove the n_lags if they will be adjusted on call</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reset lags for adjusting algorithms</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;kmeans&#39;</span><span class="p">,</span> <span class="s1">&#39;ward&#39;</span><span class="p">,</span> <span class="s1">&#39;stable_entropy&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># use the wrapper for all but even and uniform</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_wrapper</span>

        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">bin_func</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func</span> <span class="o">=</span> <span class="n">bin_func</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;bin_func has to be of type string.&#39;</span><span class="p">)</span>

        <span class="c1"># store the name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span> <span class="o">=</span> <span class="n">bin_func</span>

        <span class="c1"># reset groups and bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_bin_func_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper arounf the call of the actual binning method.</span>
<span class="sd">        This is needed to pass keyword arguments to kmeans or</span>
<span class="sd">        stable_entropy binning methods, and respect the slightly</span>
<span class="sd">        different function signature of auto_derived_lags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binning</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ward&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binning</span><span class="o">.</span><span class="n">ward</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;stable_entropy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binning</span><span class="o">.</span><span class="n">stable_entropy_lags</span><span class="p">(</span>
                <span class="n">distances</span><span class="p">,</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="n">maxlag</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binning</span><span class="o">.</span><span class="n">auto_derived_lags</span><span class="p">(</span>
                <span class="n">distances</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span><span class="p">,</span>
                <span class="n">maxlag</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span>

    <span class="nd">@normalized</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="c1"># set the new value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalized</span> <span class="o">=</span> <span class="n">status</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Distance lag bins</span>

<span class="sd">        Independent variable of the the experimental variogram sample.</span>
<span class="sd">        The bins are the upper edges of all calculated distance lag</span>
<span class="sd">        classes. If you need bin centers, use</span>
<span class="sd">        :func:`get_empirical &lt;skgstat.Variogram.get_empirical&gt;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bins : numpy.ndarray</span>
<span class="sd">            1D array of the distance lag classes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.get_empirical</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if bins are not calculated, do it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxlag</span><span class="p">)</span>
            <span class="c1"># if the binning function returned an N, the n_lags need</span>
            <span class="c1"># to be adjusted directly (not through the setter)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="o">=</span> <span class="n">n</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@bins</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
        <span class="c1"># set the new bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

        <span class="c1"># clean the groups as they are not valid anymore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_lags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of lag bins</span>

<span class="sd">        Pass the number of lag bins to be used on</span>
<span class="sd">        this Variogram instance. This will reset</span>
<span class="sd">        the grouping index and fitting parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span>

    <span class="nd">@n_lags</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_lags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># TODO: here accept strings and implement some optimum methods</span>
        <span class="c1"># string are not implemented yet</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;n_lags string values not implemented&#39;</span><span class="p">)</span>

        <span class="c1"># n_lags is int</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_lags has to be a positive integer&#39;</span><span class="p">)</span>

            <span class="c1"># set parameter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags</span> <span class="o">=</span> <span class="n">n</span>

            <span class="c1"># reset the bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># else</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_lags has to be a positive integer&#39;</span><span class="p">)</span>

        <span class="c1"># if there are no errors, store the passed value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_lags_passed_value</span> <span class="o">=</span> <span class="n">n</span>

        <span class="c1"># reset the groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># reset the fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span>

    <span class="nd">@estimator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_estimator</span><span class="p">(</span><span class="n">estimator_name</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimator_name</span><span class="p">):</span>
        <span class="c1"># reset the fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">estimator_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;matheron&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">matheron</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cressie&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">cressie</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dowd&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">dowd</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;genton&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">genton</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">minmax</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">percentile</span>
            <span class="k">elif</span> <span class="n">estimator_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;entropy&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimators</span><span class="o">.</span><span class="n">entropy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s1">&#39;Variogram estimator </span><span class="si">%s</span><span class="s1"> is not understood, please &#39;</span>
                        <span class="s1">&#39;provide the function.&#39;</span>
                    <span class="p">)</span> <span class="o">%</span> <span class="n">estimator_name</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">estimator_name</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimator_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The estimator has to be a string or callable.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.set_model"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.set_model">[docs]</a>    <span class="k">def</span> <span class="nf">set_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set model as the new theoretical variogram function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset the fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># at first reset harmonize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">model_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;harmonize&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_harmonized_model</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">model_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">model_name</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s1">&#39;The theoretical Variogram function </span><span class="si">%s</span><span class="s1"> is not&#39;</span>
                        <span class="s1">&#39; understood, please provide the function&#39;</span>
                    <span class="p">)</span> <span class="o">%</span> <span class="n">model_name</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model_name</span></div>

    <span class="k">def</span> <span class="nf">_build_harmonized_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experimental</span>

        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="n">regr</span> <span class="o">=</span> <span class="n">IsotonicRegression</span><span class="p">(</span><span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">)</span>

        <span class="c1"># create the model function</span>
        <span class="k">def</span> <span class="nf">harmonize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Monotonized Variogram</span>

<span class="sd">            Return the isotonic harmonized experimental variogram.</span>
<span class="sd">            This means, the experimental variogram is monotonic</span>
<span class="sd">            after harmonization.</span>

<span class="sd">            The harmonization is done using following Hinterding (2003)</span>
<span class="sd">            using the PAVA algorithm (Barlow and Bartholomew, 1972).</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            gamma : numpy.ndarray</span>
<span class="sd">                monotonized experimental variogram</span>

<span class="sd">            References</span>
<span class="sd">            ----------</span>
<span class="sd">            Barlow, R., D. Bartholomew, et al. (1972): Statistical</span>
<span class="sd">                Interference Under Order Restrictions. John Wiley</span>
<span class="sd">                and Sons, New York.</span>
<span class="sd">            Hiterding, A. (2003): Entwicklung hybrider Interpolations-</span>
<span class="sd">                verfahren für den automatisierten Betrieb am Beispiel</span>
<span class="sd">                meteorologischer Größen. Dissertation, Institut für</span>
<span class="sd">                Geoinformatik, Westphälische Wilhelms-Universität Münster,</span>
<span class="sd">                IfGIprints, Münster. ISBN: 3-936616-12-4</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">regr</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">regr</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">harmonize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">use_nugget</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_nugget</span>

    <span class="nd">@use_nugget</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">use_nugget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nugget</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nugget</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;use_nugget has to be of type bool.&#39;</span><span class="p">)</span>

        <span class="c1"># set new value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_nugget</span> <span class="o">=</span> <span class="n">nugget</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dist_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">dist_metric</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">wrapped_distance_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dist_func</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">dist_func</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">dist_func</span><span class="p">)</span>

    <span class="nd">@dist_function</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dist_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dist_function</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.set_dist_function"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.set_dist_function">[docs]</a>    <span class="k">def</span> <span class="nf">set_dist_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set distance function</span>

<span class="sd">        Set the function used for distance calculation. func can either be a</span>
<span class="sd">        callable or a string. The ranked distance function is not implemented</span>
<span class="sd">        yet. strings will be forwarded to the scipy.spatial.distance.pdist</span>
<span class="sd">        function as the metric argument.</span>
<span class="sd">        If func is a callable, it has to return the upper triangle of the</span>
<span class="sd">        distance matrix as a flat array (Like the pdist function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : string, callable</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset the fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;rank&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input not supported. Pass a string or callable.&#39;</span><span class="p">)</span>

        <span class="c1"># re-calculate distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">MetricSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">max_dist</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># handle sparse matrix</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangular_distance_matrix</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Turn it back to triangular form not to have duplicates</span>
        <span class="k">return</span> <span class="n">squareform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">triangular_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like distance_matrix but with zeros below the diagonal...</span>
<span class="sd">        Only defined if distance_matrix is a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s2">&quot;Only available for sparse coordinates.&quot;</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span>
            <span class="n">m</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">dists</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxlag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum lag distance to be considered in this Variogram instance.</span>
<span class="sd">        You can limit the distance at which point pairs are calcualted.</span>
<span class="sd">        There are three possible ways how to do that, in absoulte lag units,</span>
<span class="sd">        which is a number larger one. Secondly, a number ``0 &lt; maxlag &lt; 1``</span>
<span class="sd">        can be set, which will use this share of the maximum distance as</span>
<span class="sd">        maxlag. Lastly, a string can be set: ``&#39;mean&#39;`` and ``&#39;median&#39;``</span>
<span class="sd">        for the mean or median value of the distance matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This setting is largely flexible, but all options except the</span>
<span class="sd">        absolute limit in lag units need the full distance matrix to be</span>
<span class="sd">        calculated. Hence, it does **not** speed up the calculation</span>
<span class="sd">        of large distance matrices, just the estimation of the variogram.</span>
<span class="sd">        Thus, if you pre-calcualte the distance matrix using</span>
<span class="sd">        :class:`MetricSpace &lt;skgstat.MetricSpace&gt;`, only absoulte</span>
<span class="sd">        limits can be used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span>

    <span class="nd">@maxlag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">maxlag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># reset fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># remove bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set new maxlag</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxlag</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.6.2</span>

<span class="sd">        Set the fit method to be used for this Variogram instance.</span>
<span class="sd">        Possible values are:</span>

<span class="sd">        * ``&#39;trf&#39;``   - Trust-Region Reflective (default)</span>
<span class="sd">        * ``&#39;lm&#39;``    - Levenberg-Marquardt</span>
<span class="sd">        * ``&#39;ml&#39;``    - Maximum Likelihood estimation</span>
<span class="sd">        * `&#39;manual&#39;`` - Manual fitting by setting the parameters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.optimize.minimize</span>
<span class="sd">        scipy.optimize.curve_fit</span>
<span class="sd">        Variogram.fit</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default method (TRF) is a bounded least squares method,</span>
<span class="sd">        that sets constraints to the value space of all parameters.</span>
<span class="sd">        All methods use an initial guess for all used parameters.</span>
<span class="sd">        This is :func:`max(bins) &lt;skgstat.Variogram.bins&gt;` for</span>
<span class="sd">        the range,</span>
<span class="sd">        :func:`max(experimental) &lt;skgstat.Variogram.experimental&gt;`</span>
<span class="sd">        for the sill, ``20`` for the Matérn smoothness, ``2`` for</span>
<span class="sd">        the stable model shape and ``1`` for the nugget if used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_method</span>

    <span class="nd">@fit_method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fit_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span> <span class="s1">&#39;ml&#39;</span><span class="p">,</span> <span class="s1">&#39;trf&#39;</span><span class="p">,</span> <span class="s1">&#39;manual&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;fit_method has to be one of [&#39;lm&#39;, &#39;ml&#39;, &#39;trf&#39;, &#39;manual&#39;]&quot;</span>
            <span class="p">)</span>

        <span class="c1"># value is fine -check for manual does not drop the coefficients</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;manual&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_method</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span>

        <span class="c1"># otherwise - refit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_method</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># reset fit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fitting Uncertainty</span>

<span class="sd">        Set or calculate an array of observation uncertainties aligned to the</span>
<span class="sd">        Variogram.bins. These will be used to weight the observations in the</span>
<span class="sd">        cost function, which divides the residuals by their uncertainty.</span>

<span class="sd">        When setting fit_sigma, the array of uncertainties itself can be</span>
<span class="sd">        given, or one of the strings:</span>
<span class="sd">        [&#39;linear&#39;, &#39;exp&#39;, &#39;sqrt&#39;, &#39;sq&#39;, &#39;entropy&#39;].</span>
<span class="sd">        The parameters described below refer to the setter of this property.</span>

<span class="sd">        .. versionchanged:: 0.3.11</span>
<span class="sd">            added the &#39;entropy&#39; option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : string, array</span>
<span class="sd">            Sigma can either be an array of discrete uncertainty values,</span>
<span class="sd">            which have to align to the Variogram.bins, or of type string.</span>
<span class="sd">            Then, the weights for fitting are calculated as a function of</span>
<span class="sd">            (lag) distance.</span>

<span class="sd">              * **sigma=&#39;linear&#39;**: The residuals get weighted by the lag</span>
<span class="sd">                distance normalized to the maximum lag distance, denoted as</span>
<span class="sd">                :math:`w_n`</span>
<span class="sd">              * **sigma=&#39;exp&#39;**: The residuals get weighted by the function:</span>
<span class="sd">                :math:`w = e^{1 / w_n}`</span>
<span class="sd">              * **sigma=&#39;sqrt&#39;**: The residuals get weighted by the function:</span>
<span class="sd">                :math:`w = \sqrt(w_n)`</span>
<span class="sd">              * **sigma=&#39;sq&#39;**: The residuals get weighted by the function:</span>
<span class="sd">                :math:`w = w_n^2`</span>
<span class="sd">              * **sigma=&#39;entropy&#39;**: Calculates the Shannon Entropy as</span>
<span class="sd">                intrinsic uncertainty of each lag class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cost function is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            chisq = \sum {\frac{r}{\sigma}}^2</span>

<span class="sd">        where r are the residuals between the experimental variogram and the</span>
<span class="sd">        modeled values for the same lag. Following this function,</span>
<span class="sd">        small values will increase the influence of that residual, while a very</span>
<span class="sd">        large sigma will cause the observation to be ignored.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.optimize.curve_fit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># unweighted</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># discrete uncertainties</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bins</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;len(fit_sigma) != len(bins)&#39;</span><span class="p">)</span>

        <span class="c1"># linear function of distance</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>

        <span class="c1"># e function of distance</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">==</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)))</span>

        <span class="c1"># sqrt function of distance</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">==</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">))</span>

        <span class="c1"># squared function of distance</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">==</span> <span class="s1">&#39;sq&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># entropy</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">==</span> <span class="s1">&#39;entropy&#39;</span><span class="p">:</span>
            <span class="c1"># get the binning using scotts rule</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="s1">&#39;scott&#39;</span><span class="p">)</span>

            <span class="c1"># get the maximum entropy</span>
<span class="c1">#            hmax = np.log2(len(self.distance))</span>

            <span class="c1"># apply the entropy</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">shannon_entropy</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_classes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">h</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fit_sigma is not understood. It has to be an &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;array or one of [&#39;linear&#39;, &#39;exp&#39;, &#39;sqrt&#39;, &#39;sq&#39;, &#39;entropy&#39;].&quot;</span>
            <span class="p">)</span>

    <span class="nd">@fit_sigma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fit_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_sigma</span> <span class="o">=</span> <span class="n">sigma</span>

        <span class="c1"># remove fitting parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Variogram.update_kwargs"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.update_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">update_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.7</span>

<span class="sd">        Update the keyword arguments of this Variogram instance.</span>
<span class="sd">        The keyword arguments will be validated first and the update the</span>
<span class="sd">        existing kwargs. That means, you can pass only the kwargs, which</span>
<span class="sd">        need to be updated.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Updating the kwargs does not force a preprocessing circle.</span>
<span class="sd">            Any affected intermediate result, that might be cached internally,</span>
<span class="sd">            will not make use of updated kwargs. Make a call to</span>
<span class="sd">            :func:`preprocessing(force=True) &lt;skgstat.Variogram.preprocessing&gt;`</span>
<span class="sd">            to force a clean re-calculation of the Variogram instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span>

        <span class="c1"># update the keyword-arguments</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">old</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">old</span></div>

    <span class="k">def</span> <span class="nf">_validate_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.7</span>

<span class="sd">        This functions actually does nothing right now.</span>
<span class="sd">        It will be used in the future, as soon as the Variogram takes</span>
<span class="sd">        more kwargs. Then, these can be checked here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="Variogram.lag_groups"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.lag_groups">[docs]</a>    <span class="k">def</span> <span class="nf">lag_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lag class groups</span>

<span class="sd">        Retuns a mask array with as many elements as self._diff has,</span>
<span class="sd">        identifying the lag class group for each pairwise difference. Can be</span>
<span class="sd">        used to extract all pairwise values within the same lag bin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.lag_classes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_groups</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span></div>

<div class="viewcode-block" id="Variogram.lag_classes"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.lag_classes">[docs]</a>    <span class="k">def</span> <span class="nf">lag_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the lag classes</span>

<span class="sd">        Generates an iterator over all lag classes. Can be zipped with</span>
<span class="sd">        Variogram.bins to identify the lag.</span>

<span class="sd">        .. versionchanged:: 0.3.6</span>
<span class="sd">            yields an empty array for empty lag groups now</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># yield all groups</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_groups</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Variogram.preprocessing"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.preprocessing">[docs]</a>    <span class="k">def</span> <span class="nf">preprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preprocessing function</span>

<span class="sd">        Prepares all input data for the fit and transform functions. Namely,</span>
<span class="sd">        the distances are calculated and the value differences. Then the</span>
<span class="sd">        binning is set up and bin edges are calculated. If any of the listed</span>
<span class="sd">        subsets are already prepared, their processing is skipped. This</span>
<span class="sd">        behaviour can be changed by the force parameter. This will cause a</span>
<span class="sd">        clean preprocessing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : bool</span>
<span class="sd">            If set to True, all preprocessing data sets will be deleted. Use</span>
<span class="sd">            it in case you need a clean preprocessing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># call the _calc functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_diff</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_groups</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.fit"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the variogram</span>

<span class="sd">        The fit function will fit the theoretical variogram function to the</span>
<span class="sd">        experimental. The preprocessed distance matrix, pairwise differences</span>
<span class="sd">        and binning will not be recalculated, if already done. This could be</span>
<span class="sd">        forced by setting the force parameter to true.</span>

<span class="sd">        In case you call fit function directly, with method or sigma,</span>
<span class="sd">        the parameters set on Variogram object instantiation will get</span>
<span class="sd">        overwritten. All other keyword arguments will be passed to</span>
<span class="sd">        scipy.optimize.curve_fit function.</span>

<span class="sd">        .. versionchanged:: 0.3.10</span>
<span class="sd">            added &#39;ml&#39; and &#39;custom&#39; method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : bool</span>
<span class="sd">            If set to True, a clean preprocessing of the distance matrix,</span>
<span class="sd">            pairwise differences and the binning will be forced. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        method : string</span>
<span class="sd">            A string identifying one of the implemented fitting procedures.</span>
<span class="sd">            Can be one of:</span>

<span class="sd">              * lm: Levenberg-Marquardt algorithms implemented in</span>
<span class="sd">                scipy.optimize.leastsq function.</span>
<span class="sd">              * trf: Trust Region Reflective algorithm implemented in</span>
<span class="sd">                scipy.optimize.least_squares(method=&#39;trf&#39;)</span>
<span class="sd">              * &#39;ml&#39;: Maximum-Likelihood estimation. With the current</span>
<span class="sd">                implementation only the Nelder-Mead solver for unconstrained</span>
<span class="sd">                problems is implemented. This will estimate the variogram</span>
<span class="sd">                parameters from a Gaussian parameter space by minimizing</span>
<span class="sd">                the negative log-likelihood.</span>
<span class="sd">              * &#39;manual&#39;: Manual fitting. You can set the range, sill and</span>
<span class="sd">                nugget either directly to the</span>
<span class="sd">                :func:`fit &lt;skgstat.Variogram.fit&gt;` function, or as</span>
<span class="sd">                `fit_` prefixed keyword arguments on Variogram instantiation.</span>


<span class="sd">        sigma : string, array</span>
<span class="sd">            Uncertainty array for the bins. Has to have the same dimension as</span>
<span class="sd">            self.bins. Refer to Variogram.fit_sigma for more information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.optimize.minimize</span>
<span class="sd">        scipy.optimize.curve_fit</span>
<span class="sd">        scipy.optimize.leastsq</span>
<span class="sd">        scipy.optimize.least_squares</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store the old cof</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>

        <span class="c1"># delete the last cov and cof</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># if force, force a clean preprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

        <span class="c1"># load the data</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experimental</span>

        <span class="c1"># overwrite fit setting if new params are given</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span> <span class="o">=</span> <span class="n">sigma</span>

        <span class="c1"># remove nans</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

        <span class="c1"># handle harmonized models</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize</span><span class="p">:</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span>

            <span class="c1"># get the params</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">_y</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span> <span class="k">else</span> <span class="mf">0.0</span>

            <span class="c1"># set the params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="c1"># Switch the method</span>
        <span class="c1"># wrap the model to include or exclude the nugget</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># get p0</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_fit_bounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Trust Region Reflective</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">==</span> <span class="s1">&#39;trf&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">wrapped</span><span class="p">,</span>
                <span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trf&#39;</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span><span class="p">,</span>
                <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="c1"># Levenberg-Marquardt</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">==</span> <span class="s1">&#39;lm&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">wrapped</span><span class="p">,</span>
                <span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span><span class="p">,</span>
                <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="c1"># maximum-likelihood</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">==</span> <span class="s1">&#39;ml&#39;</span><span class="p">:</span>
            <span class="c1"># check if the probabilities must be weighted</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span>

            <span class="c1"># define the loss function to be minimized</span>
            <span class="k">def</span> <span class="nf">ml</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="c1"># predict</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">wrapped</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_x</span><span class="p">]</span>

                <span class="c1"># get the probabilities of _y</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">_p</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">o</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> <span class="k">for</span> <span class="n">_p</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">_y</span><span class="p">)]</span>

                <span class="c1"># weight the probs</span>
                <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>

            <span class="c1"># apply maximum likelihood estimation by minimizing ml</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">ml</span><span class="p">,</span> <span class="n">p0</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">p0</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">OptimizeWarning</span><span class="p">(</span><span class="s1">&#39;Maximum Likelihood could not estimate parameters.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set the result</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>

        <span class="c1"># manual fitting</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">==</span> <span class="s1">&#39;manual&#39;</span><span class="p">:</span>
            <span class="c1"># TODO: here, the Error could only be raises if cof was None so far</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fit_range&#39;</span><span class="p">,</span> <span class="n">old_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;effective_range&#39;</span><span class="p">)))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sill&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fit_sill&#39;</span><span class="p">,</span> <span class="n">old_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sill&#39;</span><span class="p">)))</span>

            <span class="c1"># if not given raise an AttributeError</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;For manual fitting, you need to pass the </span><span class="se">\</span>
<span class="s1">                    variogram parameters either to fit or to the Variogram </span><span class="se">\</span>
<span class="s1">                    instance.</span><span class="se">\n</span><span class="s1"> parameter need to be prefixed with fit_ if </span><span class="se">\</span>
<span class="s1">                    passed to __init__.&#39;</span><span class="p">)</span>

            <span class="c1"># get the nugget</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nugget&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fit_nugget&#39;</span><span class="p">,</span> <span class="n">old_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nugget&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)))</span>

            <span class="c1"># check if a s parameter is needed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;stable&#39;</span><span class="p">,</span> <span class="s1">&#39;matern&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
                    <span class="n">s2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fit_shape&#39;</span><span class="p">,</span> <span class="n">old_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;matern&#39;</span><span class="p">:</span>
                    <span class="n">s2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fit_shape&#39;</span><span class="p">,</span> <span class="n">old_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;smoothness&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)))</span>

                <span class="c1"># set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="Variogram.transform"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform</span>

<span class="sd">        Transform a given set of lag values to the theoretical variogram</span>
<span class="sd">        function using the actual fitting and preprocessing parameters in</span>
<span class="sd">        this Variogram instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numpy.array</span>
<span class="sd">            Array of lag values to be used as model input for the fitted</span>
<span class="sd">            theoretical variogram model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">()</span>

        <span class="c1"># if instance is not fitted, fit it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># return the result</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted_model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fitted_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fitted Model</span>

<span class="sd">        Returns a callable that takes a distance value and returns a</span>
<span class="sd">        semivariance. This model is fitted to the current Variogram</span>
<span class="sd">        parameters. The function will be interpreted at return time with the</span>
<span class="sd">        parameters hard-coded into the function code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : callable</span>
<span class="sd">            The current semivariance model fitted to the current Variogram</span>
<span class="sd">            model parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get the pars</span>
        <span class="n">cof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted_model_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fitted_model_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Make sure to keep this synchronized with the output</span>
            <span class="c1"># of describe()!</span>
            <span class="n">cof</span> <span class="o">=</span> <span class="p">[</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;effective_range&quot;</span><span class="p">],</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;sill&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="s2">&quot;smoothness&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                <span class="n">cof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;smoothness&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;shape&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                <span class="n">cof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;nugget&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="s2">&quot;nugget&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;harmonize&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please supply the actual harmonized model directly&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">model</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;harmonize&quot;</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;fitted_model = lambda x: model(x)&quot;&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;fitted_model = lambda x: model(x, </span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">cof</span><span class="p">]))</span>

        <span class="c1"># run the code</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="n">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">[</span><span class="s1">&#39;fitted_model&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_calc_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the pairwise differences</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        void</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># already calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># handle sparse matrix</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangular_distance_matrix</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
            <span class="n">Vcol</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">indices</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">Vrow</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">indices</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

            <span class="c1"># self._diff will have same shape as self.distances, even</span>
            <span class="c1"># when that&#39;s not in diagonal format...</span>
            <span class="c1"># Note: it might be compelling to do np.abs(Vrow -</span>
            <span class="c1"># Vcol).data instead here, but that might optimize away</span>
            <span class="c1"># some zeros, leaving _diff in a different shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Vrow</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">Vcol</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Append a column of zeros to make pdist happy</span>
            <span class="c1"># euclidean: sqrt((a-b)**2 + (0-0)**2) == sqrt((a-b)**2)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)))),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the lag class mask array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># already calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get the bin edges and distances</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span>

        <span class="c1"># -1 is the group fir distances outside maxlag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="n">bin_edges</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span> <span class="o">=</span> <span class="n">i</span>

<div class="viewcode-block" id="Variogram.clone"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of self</span>

<span class="sd">        Return a deep copy of self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Variogram</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">experimental</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Experimental Variogram</span>

<span class="sd">        Array of experimental (empirical) semivariance values. The array</span>
<span class="sd">        length will be aligned to Variogram.bins. The current</span>
<span class="sd">        Variogram.estimator has been used to calculate the values. Depending</span>
<span class="sd">        on the setting of Variogram.harmonize (True | False), either</span>
<span class="sd">        Variogram._experimental or Variogram.isotonic will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vario : numpy.ndarray</span>
<span class="sd">            Array of the experimental semi-variance values aligned to</span>
<span class="sd">            Variogram.bins.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram._experimental</span>
<span class="sd">        Variogram.isotonic</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_experimental</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_experimental</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the experimental variogram from the current lag classes.</span>
<span class="sd">        It handles the special case of the `&#39;entropy&#39;` and `&#39;percentile&#39;`</span>
<span class="sd">        estimators, which take an additional argument.</span>

<span class="sd">        .. versionchanged:: 0.3.6</span>
<span class="sd">            replaced the for-loops with :func:`fromiter &lt;numpy.fromiter&gt;`</span>

<span class="sd">        .. versionchanged:: 0.3.7</span>
<span class="sd">            makes use of `kwargs &lt;skgstat.Variogram._kwargs&gt;` for</span>
<span class="sd">            specific estimators now</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        experimental : np.ndarray</span>
<span class="sd">            1D array of the experimental variogram values. Has same length</span>
<span class="sd">            as :func:`bins &lt;skgstat.Variogram.bins&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;entropy&#39;</span><span class="p">:</span>
            <span class="c1"># get the parameter from kwargs, if not set use 50</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;entropy_bins&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

            <span class="c1"># we need to use N -1 as we use the last inclusive</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

            <span class="c1"># define the mapper to the estimator function</span>
            <span class="k">def</span> <span class="nf">mapper</span><span class="p">(</span><span class="n">lag_values</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="p">(</span><span class="n">lag_values</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;percentile&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;percentile&#39;</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">mapper</span><span class="p">(</span><span class="n">lag_values</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="p">(</span><span class="n">lag_values</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span>

        <span class="c1"># return the mapped result</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_classes</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.get_empirical"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.get_empirical">[docs]</a>    <span class="k">def</span> <span class="nf">get_empirical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_center</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Empirical variogram</span>

<span class="sd">        Returns a tuple of dependent and independent sample values, this</span>
<span class="sd">        :class:`Variogram &lt;skgstat.Variogram&gt;` is estimated for.</span>
<span class="sd">        This is a tuple of the current :func:`bins &lt;skgstat.Variogram.bins&gt;`</span>
<span class="sd">        and :func:`experimental &lt;skgstat.Variogram.experimental&gt;`</span>
<span class="sd">        semi-variance values. By default the upper bin edges are used.</span>
<span class="sd">        This can be set to bin center by the `bin_center` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_center : bool</span>
<span class="sd">            If set to `True`, the center for each distance lag bin is</span>
<span class="sd">            used over the upper limit (default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bins : numpy.ndarray</span>
<span class="sd">            1D array of :func:`n_lags &lt;skgstat.Variogram.n_lags&gt;`</span>
<span class="sd">            distance lag bins.</span>
<span class="sd">        experimental : numpy.ndarray</span>
<span class="sd">            1D array of :func:`n_lags &lt;skgstat.Variogram.n_lags&gt;`</span>
<span class="sd">            experimental semi-variance values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.bins</span>
<span class="sd">        Variogram.experimental</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the bins and experimental values</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>
        <span class="n">experimental</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experimental</span>

        <span class="c1"># align bin centers</span>
        <span class="k">if</span> <span class="n">bin_center</span><span class="p">:</span>
            <span class="c1"># get the bin centers</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bins</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># return</span>
        <span class="k">return</span> <span class="n">bins</span><span class="p">,</span> <span class="n">experimental</span></div>

    <span class="k">def</span> <span class="nf">__get_fit_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bounds for parameter space in fitting a variogram model.</span>
<span class="sd">        The bounds are depended on the Model that is used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># use range, sill and smoothness parameter</span>
        <span class="k">if</span> <span class="n">mname</span> <span class="o">==</span> <span class="s1">&#39;matern&#39;</span><span class="p">:</span>
            <span class="c1"># a is max(x), C0 is max(y) s is limited to 20?</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mf">20.</span><span class="p">]</span>

        <span class="c1"># use range, sill and shape parameter</span>
        <span class="k">elif</span> <span class="n">mname</span> <span class="o">==</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
            <span class="c1"># a is max(x), C0 is max(y) s is limited to 2?</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mf">2.</span><span class="p">]</span>

        <span class="c1"># use only sill</span>
        <span class="k">elif</span> <span class="n">mname</span> <span class="o">==</span> <span class="s1">&#39;nugget&#39;</span><span class="p">:</span>
            <span class="c1"># a is max(x):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="c1"># use range and sill</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># a is max(x), C0 is max(y)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

        <span class="c1"># if use_nugget is True add the nugget</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span><span class="p">:</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.99</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">bounds</span>

<div class="viewcode-block" id="Variogram.data"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.data">[docs]</a>    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Theoretical variogram function</span>

<span class="sd">        Calculate the experimental variogram and apply the binning. On</span>
<span class="sd">        success, the variogram model will be fitted and applied to n lag</span>
<span class="sd">        values. Returns the lags and the calculated semi-variance values.</span>
<span class="sd">        If force is True, a clean preprocessing and fitting run will be</span>
<span class="sd">        executed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            length of the lags array to be used for fitting. Defaults to 100,</span>
<span class="sd">            which will be fine for most plots</span>
<span class="sd">        force: boolean</span>
<span class="sd">            If True, the preprocessing and fitting will be executed as a</span>
<span class="sd">            clean run. This will force all intermediate results to be</span>
<span class="sd">            recalculated. Defaults to False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        variogram : tuple</span>
<span class="sd">            first element is the created lags array</span>
<span class="sd">            second element are the calculated semi-variance values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># force a clean preprocessing if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

        <span class="c1"># calculate the experimental variogram</span>
        <span class="n">_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">_bin</span><span class="p">)),</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># fit if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cof</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_propagate_obs_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Observation uncertainties are propagated into the experimental</span>
<span class="sd">        variogram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># due to circular import, import here</span>
        <span class="kn">from</span> <span class="nn">skgstat.util.uncertainty</span> <span class="kn">import</span> <span class="n">propagate</span>

        <span class="c1"># TODO: load and propagate percentile settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_experimental_conf_interval</span> <span class="o">=</span> <span class="n">propagate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="s1">&#39;values&#39;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="s1">&#39;obs_sigma&#39;</span><span class="p">],</span>
            <span class="n">use_bounds</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Model residuals</span>

<span class="sd">        Calculate the model residuals defined as the differences between the</span>
<span class="sd">        experimental variogram and the theoretical model values at</span>
<span class="sd">        corresponding lag values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the deviations</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>

        <span class="c1"># calculate the residuals</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">experimental</span><span class="p">),</span> <span class="nb">float</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mean_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mean Model residuals</span>

<span class="sd">        Calculates the mean, absoulte deviations between the experimental</span>
<span class="sd">        variogram and theretical model values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">),</span> <span class="nb">float</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;RMSE</span>

<span class="sd">        Calculate the Root Mean squared error between the experimental</span>
<span class="sd">        variogram and the theoretical model values at corresponding lags.</span>
<span class="sd">        Can be used as a fitting quality measure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The RMSE is implemented like:</span>

<span class="sd">        .. math::</span>
<span class="sd">            RMSE = \sqrt{\frac{\sum_{i=0}^{i=N(x)} (x-y)^2}{N(x)}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the deviations</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>

        <span class="c1"># get the sum of squares</span>
        <span class="n">rsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rsum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;RMSE</span>

<span class="sd">        Calculate the Mean squared error between the experimental</span>
<span class="sd">        variogram and the theoretical model values at corresponding lags.</span>
<span class="sd">        Can be used as a fitting quality measure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The MSE is implemented like:</span>

<span class="sd">        .. math::</span>
<span class="sd">            MSE = \frac{\sum_{i=0}^{i=N(x)} (x-y)^2}{N(x)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the deviations</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>

        <span class="c1"># get the mean</span>
        <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">experimental</span><span class="p">,</span> <span class="n">model</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mse</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;RMSE</span>

<span class="sd">        Calculate the Mean absolute error between the experimental</span>
<span class="sd">        variogram and the theoretical model values at corresponding lags.</span>
<span class="sd">        Can be used as a fitting quality measure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The MAE is implemented like:</span>

<span class="sd">        .. math::</span>
<span class="sd">            MAE = \frac{\sum_{i=0}^{i=N(x)} |x-y|}{N(x)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the deviations</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>

        <span class="c1"># get the mean</span>
        <span class="n">mae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">experimental</span><span class="p">,</span> <span class="n">model</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">mae</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nrmse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;NRMSE</span>

<span class="sd">        Calculate the normalized root mean squared error between the</span>
<span class="sd">        experimental variogram and the theoretical model values at</span>
<span class="sd">        corresponding lags. Can be used as a fitting quality measure</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.residuals</span>
<span class="sd">        Variogram.rmse</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The NRMSE is implemented as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            NRMSE = \frac{RMSE}{mean(y)}</span>

<span class="sd">        where RMSE is Variogram.rmse and y is Variogram.experimental</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmse</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nrmse_r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;NRMSE</span>

<span class="sd">        Alternative normalized root mean squared error between the</span>
<span class="sd">        experimental variogram and the theoretical model values at</span>
<span class="sd">        corresponding lags. Can be used as a fitting quality measure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.rmse</span>
<span class="sd">        Variogram.nrmse</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike Variogram.nrmse, nrmse_r is not normalized to the mean of y,</span>
<span class="sd">        but the differece of the maximum y to its mean:</span>

<span class="sd">        .. math::</span>
<span class="sd">            NRMSE_r = \frac{RMSE}{max(y) - mean(y)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experimental</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmse</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">_y</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pearson correlation of the fitted Variogram</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the experimental and theoretical variogram and cacluate means</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">experimental</span><span class="p">)</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># calculate the single pearson correlation terms</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">my</span><span class="p">),</span> <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span><span class="p">),</span> <span class="nb">float</span>
        <span class="p">))</span>

        <span class="n">t2x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">experimental</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">t2y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">my</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">model</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">term1</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t2x</span> <span class="o">*</span> <span class="n">t2y</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nash Sutcliffe efficiency of the fitted Variogram</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_deviations</span><span class="p">()</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">experimental</span><span class="p">)</span>

        <span class="c1"># calculate the single nash-sutcliffe terms</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">experimental</span><span class="p">,</span> <span class="n">model</span><span class="p">),</span>
            <span class="nb">float</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">experimental</span><span class="p">),</span>
            <span class="nb">float</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">term1</span> <span class="o">/</span> <span class="n">term2</span><span class="p">)</span>

<div class="viewcode-block" id="Variogram.model_deviations"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.model_deviations">[docs]</a>    <span class="k">def</span> <span class="nf">model_deviations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Model Deviations</span>

<span class="sd">        Calculate the deviations between the experimental variogram and the</span>
<span class="sd">        recalculated values for the same bins using the fitted theoretical</span>
<span class="sd">        variogram function. Can be utilized to calculate a quality measure</span>
<span class="sd">        for the variogram fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deviations : tuple</span>
<span class="sd">            first element is the experimental variogram</span>
<span class="sd">            second element are the corresponding values of the theoretical</span>
<span class="sd">            model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the experimental values and their bin bounds</span>
        <span class="n">_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">experimental</span>
        <span class="n">_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span>

        <span class="c1"># get the model parameters</span>
        <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The variogram cannot be calculated.&#39;</span><span class="p">)</span>

        <span class="c1"># calculate the model values at bin bounds</span>
        <span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">_bin</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_exp</span><span class="p">,</span> <span class="n">_model</span></div>

<div class="viewcode-block" id="Variogram.cross_validate"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.cross_validate">[docs]</a>    <span class="k">def</span> <span class="nf">cross_validate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;jacknife&#39;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;rmse&#39;</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cross validation of the variogram model by means of Kriging.</span>
<span class="sd">        Right now, this function can only utilize a jacknife (leave-one-out)</span>
<span class="sd">        cross validation and will only use the builtin OrdinaryKriging</span>
<span class="sd">        method (not yet the to_gs_krige interface).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            Right now, &#39;jacknife&#39; is the only possible input.</span>
<span class="sd">        n : int</span>
<span class="sd">            The number of points to be included into the cross-validation.</span>
<span class="sd">            If None (default), all points will be used.</span>
<span class="sd">        metric : str</span>
<span class="sd">            Metric used for cross-validation.</span>
<span class="sd">            Can be root mean square error (rmse), mean squared error (mse)</span>
<span class="sd">            or mean absolute error (mae).</span>
<span class="sd">        seed : int</span>
<span class="sd">            If n is not None, the random selection of input data for the</span>
<span class="sd">            cross-validation can be seeded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metric : float</span>
<span class="sd">            The cross-validation result as specified above.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        skgstat.util.cross_validation.jacknife</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># not sure how to solve the circular import here</span>
        <span class="kn">from</span> <span class="nn">skgstat.util</span> <span class="kn">import</span> <span class="n">cross_validation</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jacknife&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">jacknife</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.describe"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Variogram parameters</span>

<span class="sd">        Return a dictionary of the variogram parameters.</span>

<span class="sd">        .. versionchanged:: 0.3.7</span>
<span class="sd">            The describe now returns all init parameters in as the</span>
<span class="sd">            `describe()[&#39;params&#39;]` key and all keyword arguments as</span>
<span class="sd">            `describe()[&#39;kwargs&#39;]`. This output can be suppressed</span>
<span class="sd">            by setting `short=True`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        short : bool</span>
<span class="sd">            If `True`, the `&#39;params&#39;` and `&#39;kwargs&#39;` keys will be</span>
<span class="sd">            omitted. Defaults to `False`.</span>
<span class="sd">        flat : bool</span>
<span class="sd">            If `True`, the `&#39;params&#39;` and `&#39;kwargs&#39;` nested `dict`s</span>
<span class="sd">            will be distributed to the main `dict` to return a</span>
<span class="sd">            flat `dict`. Defaults to `False`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        parameters : dict</span>
<span class="sd">            Returns fitting parameters of the theoretical variogram</span>
<span class="sd">            model along with the init parameters of the</span>
<span class="sd">            `Variogram &lt;skgstat.Variogram&gt;` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fit, if not already done</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># scale sill and range</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">maxvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>

        <span class="c1"># get the fitting coefficents</span>
        <span class="n">cof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cof</span>

        <span class="c1"># build the dict</span>

        <span class="k">def</span> <span class="nf">fnname</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">fn</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;skgstat.&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">name</span>

        <span class="n">rdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">fnname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize</span> <span class="k">else</span> <span class="s2">&quot;harmonize&quot;</span><span class="p">,</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">fnname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="p">),</span>
            <span class="n">dist_func</span><span class="o">=</span><span class="n">fnname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_function</span><span class="p">),</span>

            <span class="n">normalized_effective_range</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxlag</span><span class="p">,</span>
            <span class="n">normalized_sill</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxvar</span><span class="p">,</span>
            <span class="n">normalized_nugget</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxvar</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>

            <span class="n">effective_range</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">sill</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">nugget</span><span class="o">=</span><span class="n">cof</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># handle s parameters for matern and stable model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;matern&#39;</span><span class="p">:</span>
            <span class="n">rdict</span><span class="p">[</span><span class="s1">&#39;smoothness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cof</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
            <span class="n">rdict</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cof</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># add other stuff if not short version requested</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">short</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">dist_func</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_function</span><span class="p">),</span>
                <span class="n">bin_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_func_name</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">,</span>
                <span class="n">fit_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_method</span><span class="p">,</span>
                <span class="n">fit_sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sigma</span><span class="p">,</span>
                <span class="n">use_nugget</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_nugget</span><span class="p">,</span>
                <span class="n">maxlag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxlag</span><span class="p">,</span>
                <span class="n">n_lags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_lags_passed_value</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
            <span class="p">)</span>

            <span class="c1"># update or append the params</span>
            <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                <span class="n">rdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">rdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rdict</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
                <span class="n">rdict</span><span class="p">[</span><span class="s1">&#39;kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># return</span>
        <span class="k">return</span> <span class="n">rdict</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract just the variogram parameters range, sill</span>
<span class="sd">        and nugget from the</span>
<span class="sd">        :func:`describe &lt;skgstat.Variogram.describe&gt;` output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : list</span>
<span class="sd">            [range, sill, nugget] for most models and</span>
<span class="sd">            [range, sill, shape, nugget] for matern and stable model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;matern&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">([</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;effective_range&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;smoothness&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">]</span>
            <span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">([</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;effective_range&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">]</span>
            <span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;nugget&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">([</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;effective_range&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">],</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">]</span>
            <span class="p">])</span>

<div class="viewcode-block" id="Variogram.to_DataFrame"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.to_DataFrame">[docs]</a>    <span class="k">def</span> <span class="nf">to_DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Variogram DataFrame</span>

<span class="sd">        Returns the fitted theoretical variogram as a pandas.DataFrame</span>
<span class="sd">        instance. The n and force parameter control the calaculation,</span>
<span class="sd">        refer to the data funciton for more info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : integer</span>
<span class="sd">            length of the lags array to be used for fitting. Defaults to 100,</span>
<span class="sd">            which will be fine for most plots</span>
<span class="sd">        force: boolean</span>
<span class="sd">            If True, the preprocessing and fitting will be executed as a</span>
<span class="sd">            clean run. This will force all intermediate results to be</span>
<span class="sd">            recalculated. Defaults to False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Variogram.data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lags</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;lags&#39;</span><span class="p">:</span> <span class="n">lags</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
        <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Variogram.to_gstools"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.to_gstools">[docs]</a>    <span class="k">def</span> <span class="nf">to_gstools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate a corresponding GSTools CovModel.</span>

<span class="sd">        By default, this will be an isotropic model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments forwarded to the instantiated GSTools CovModel.</span>
<span class="sd">            The default parameters &#39;dim&#39;, &#39;var&#39;, &#39;len_scale&#39;, &#39;nugget&#39;,</span>
<span class="sd">            &#39;rescale&#39; and optional shape parameters will be extracted</span>
<span class="sd">            from the given Variogram but they can be overwritten here.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            When GSTools is not installed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When GSTools version is not v1.3 or greater.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When given Variogram model is not supported (&#39;harmonize&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :any:`CovModel`</span>
<span class="sd">            Corresponding GSTools covmodel.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        In case you intend to use the</span>
<span class="sd">        :func:`coordinates &lt;skgstat.Variogram.coordinates&gt;`</span>
<span class="sd">        in a GSTools workflow, you need to transpose the coordinate</span>
<span class="sd">        array like:</span>

<span class="sd">        &gt;&gt; cond_pos Variogram.coordinates.T</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first fit again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">skgstat_to_gstools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.to_gs_krige"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.to_gs_krige">[docs]</a>    <span class="k">def</span> <span class="nf">to_gs_krige</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instatiate a GSTools Krige class.</span>

<span class="sd">        This can only export isotropic models.</span>
<span class="sd">        Note: the `fit_variogram` is always set to `False`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variogram : skgstat.Variogram</span>
<span class="sd">            Scikit-GStat Variogram instamce</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments forwarded to GSTools Krige.</span>
<span class="sd">            Refer to :any:`Krige &lt;gstools.krige.Krige&gt;` to</span>
<span class="sd">            learn about all possible options.</span>
<span class="sd">            Note that the `fit_variogram` parameter will</span>
<span class="sd">            always be False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            When GSTools is not installed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When GSTools version is not v1.3 or greater.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When given Variogram model is not supported (&#39;harmonize&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :any:`Krige`</span>
<span class="sd">            Instantiated GSTools Krige class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        gstools.Krige</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fit </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">skgstat_to_krige</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.plot"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Variogram Plot</span>

<span class="sd">        Plot the experimental variogram, the fitted theoretical function and</span>
<span class="sd">        an histogram for the lag classes. The axes attribute can be used to</span>
<span class="sd">        pass a list of AxesSubplots or a single instance to the plot</span>
<span class="sd">        function. Then these Subplots will be used. If only a single instance</span>
<span class="sd">        is passed, the hist attribute will be ignored as only the variogram</span>
<span class="sd">        will be plotted anyway.</span>

<span class="sd">        .. versionchanged:: 0.4.0</span>
<span class="sd">            This plot can be plotted with the plotly plotting backend</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list, tuple, array, AxesSubplot or None</span>
<span class="sd">            If None, the plot function will create a new matplotlib figure.</span>
<span class="sd">            Otherwise a single instance or a list of AxesSubplots can be</span>
<span class="sd">            passed to be used. If a single instance is passed, the hist</span>
<span class="sd">            attribute will be ignored.</span>
<span class="sd">        grid : bool</span>
<span class="sd">            Defaults to True. If True a custom grid will be drawn through</span>
<span class="sd">            the lag class centers</span>
<span class="sd">        show : bool</span>
<span class="sd">            Defaults to True. If True, the show method of the passed or</span>
<span class="sd">            created matplotlib Figure will be called before returning the</span>
<span class="sd">            Figure. This should be set to False, when used in a Notebook,</span>
<span class="sd">            as a returned Figure object will be plotted anyway.</span>
<span class="sd">        hist : bool</span>
<span class="sd">            Defaults to True. If False, the creation of a histogram for the</span>
<span class="sd">            lag classes will be suppressed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.Figure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the backend</span>
        <span class="n">used_backend</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">backend</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">matplotlib_variogram_plot</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="n">hist</span><span class="o">=</span><span class="n">hist</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;plotly&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">plotly_variogram_plot</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="n">hist</span><span class="o">=</span><span class="n">hist</span>
            <span class="p">)</span>

        <span class="c1"># if we reach this line, somethings wrong with plotting backend</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The plotting backend has an undefined state.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.scattergram"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.scattergram">[docs]</a>    <span class="k">def</span> <span class="nf">scattergram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Scattergram plot</span>

<span class="sd">        Groups the values by lags and plots the head and tail values</span>
<span class="sd">        of all point pairs within the groups against each other.</span>
<span class="sd">        This can be used to investigate the distribution of the</span>
<span class="sd">        value residuals.</span>

<span class="sd">        .. versionchanged:: 0.4.0</span>
<span class="sd">            This plot can be plotted with the plotly plotting backend</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.Axes, plotly.graph_objects.Figure</span>
<span class="sd">            If None, a new plotting Figure will be created. If given,</span>
<span class="sd">            it has to be an instance of the used plotting backend, which</span>
<span class="sd">            will be used to plot on.</span>
<span class="sd">        show : boolean</span>
<span class="sd">            If True (default), the `show` method of the Figure will be</span>
<span class="sd">            called. Can be set to False to prevent duplicated plots in</span>
<span class="sd">            some environments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.Figure, plotly.graph_objects.Figure</span>
<span class="sd">            Resulting figure, depending on the plotting backend</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the backend</span>
        <span class="n">used_backend</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">backend</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">matplotlib_variogram_scattergram</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;plotly&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">plotly_variogram_scattergram</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="c1"># if we reach this line, somethings wrong with plotting backend</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The plotting backend has an undefined state.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.location_trend"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.location_trend">[docs]</a>    <span class="k">def</span> <span class="nf">location_trend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Location Trend plot</span>

<span class="sd">        Plots the values over each dimension of the coordinates in a scatter</span>
<span class="sd">        plot. This will visually show correlations between the values and any</span>
<span class="sd">        of the coordinate dimension. If there is a value dependence on the</span>
<span class="sd">        location, this would violate the intrinsic hypothesis. This is a</span>
<span class="sd">        weaker form of stationarity of second order.</span>

<span class="sd">        .. versionchanged:: 0.4.0</span>
<span class="sd">            This plot can be plotted with the plotly plotting backend</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list</span>
<span class="sd">            Can be None (default) or a list of matplotlib.AxesSubplots. If a</span>
<span class="sd">            list is passed, the location trend plots will be plotted on the</span>
<span class="sd">            given instances. Note that then length of the list has to match</span>
<span class="sd">            the dimeonsionality of the coordinates array. In case 3D</span>
<span class="sd">            coordinates are used, three subplots have to be given.</span>
<span class="sd">        show : boolean</span>
<span class="sd">            If True (default), the `show` method of the Figure will be</span>
<span class="sd">            called. Can be set to False to prevent duplicated plots in</span>
<span class="sd">            some environments.</span>

<span class="sd">        Keyword Arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        add_trend_line : bool</span>
<span class="sd">            .. versionadded:: 0.3.5</span>

<span class="sd">            If set to `True`, the class will fit a linear model to each</span>
<span class="sd">            coordinate dimension and output the model along with a</span>
<span class="sd">            calculated R². With high R² values, you should consider</span>
<span class="sd">            rejecting the input data, or transforming it.</span>

<span class="sd">            .. note::</span>
<span class="sd">                Right now, this is only supported for ``&#39;plotly&#39;`` backend</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.Figure, plotly.graph_objects.Figure</span>
<span class="sd">            The figure produced by the function. Dependends on the</span>
<span class="sd">            current backend.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the backend</span>
        <span class="n">used_backend</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">backend</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">matplotlib_location_trend</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;plotly&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">plotly_location_trend</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="c1"># if we reach this line, somethings wrong with plotting backend</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The plotting backend has an undefined state.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Variogram.distance_difference_plot"><a class="viewcode-back" href="../../reference/variogram.html#skgstat.Variogram.distance_difference_plot">[docs]</a>    <span class="k">def</span> <span class="nf">distance_difference_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_bins</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw distance plot</span>

<span class="sd">        Plots all absoulte value differences of all point pair combinations</span>
<span class="sd">        over their separating distance, without sorting them into a lag.</span>

<span class="sd">        .. versionchanged:: 0.4.0</span>
<span class="sd">            This plot can be plotted with the plotly plotting backend</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : None, AxesSubplot</span>
<span class="sd">            If None, a new matplotlib.Figure will be created. In case a</span>
<span class="sd">            Figure was already created, pass the Subplot to use as ax argument.</span>
<span class="sd">        plot_bins : bool</span>
<span class="sd">            If True (default) the bin edges will be included into the plot.</span>
<span class="sd">        show : bool</span>
<span class="sd">            If True (default), the show method of the Figure will be called</span>
<span class="sd">            before returning the Figure. Can be set to False, to avoid</span>
<span class="sd">            doubled figure rendering in Jupyter notebooks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.pyplot.Figure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the backend</span>
        <span class="n">used_backend</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">backend</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">matplotlib_dd_plot</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">plot_bins</span><span class="o">=</span><span class="n">plot_bins</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">used_backend</span> <span class="o">==</span> <span class="s1">&#39;plotly&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotting</span><span class="o">.</span><span class="n">plotly_dd_plot</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">plot_bins</span><span class="o">=</span><span class="n">plot_bins</span><span class="p">,</span>
                <span class="n">show</span><span class="o">=</span><span class="n">show</span>
            <span class="p">)</span>

        <span class="c1"># if we reach this line, somethings wrong with plotting backend</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The plotting backend has an undefined state.&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Textual representation of this Variogram instance.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt; abstract Variogram &gt;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt; </span><span class="si">%s</span><span class="s2"> Semivariogram fitted to </span><span class="si">%d</span><span class="s2"> bins &gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;String Representation</span>

<span class="sd">        Descriptive respresentation of this Variogram instance that shall give</span>
<span class="sd">        the main variogram parameters in a print statement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        description : str</span>
<span class="sd">            String description of the variogram instance. Described by the</span>
<span class="sd">            Variogram parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>

        <span class="n">_sill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">par</span> <span class="k">else</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;sill&#39;</span><span class="p">]</span>
        <span class="n">_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">par</span> <span class="k">else</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;effective_range&#39;</span><span class="p">]</span>
        <span class="n">_nugget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">par</span> <span class="k">else</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;nugget&#39;</span><span class="p">]</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> Variogram</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;Estimator:         </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">        </span><span class="se">\r</span><span class="s2">Effective Range:   </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">        </span><span class="se">\r</span><span class="s2">Sill:              </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">        </span><span class="se">\r</span><span class="s2">Nugget:            </span><span class="si">%.2f</span><span class="s2"></span>
<span class="s2">        &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;estimator&#39;</span><span class="p">],</span> <span class="n">_range</span><span class="p">,</span> <span class="n">_sill</span><span class="p">,</span> <span class="n">_nugget</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, Mirko Mälicke.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>