
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Variography &#8212; SciKit GStat 0.6.4 documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "document", "processHtmlClass": "math|output_area"}}</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interpolation" href="kriging.html" />
    <link rel="prev" title="Introduction" href="introduction.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">SciKit GStat</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/tutorials.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../technical/technical.html">
  Technical Notes
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/reference.html">
  Code Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../changelog.html">
  Changelog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference external nav-link" href="https://mmaelicke.github.io/scikit-gstat/SciKitGStat.pdf">
  PDF
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/mmaelicke/scikit-gstat" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p class="caption">
 <span class="caption-text">
  Contents
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Variography
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kriging.html">
   Interpolation
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-variogram">
   The variogram
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general">
     General
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#using-scikit-gstat">
       Using scikit-gstat
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#distance">
     Distance
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#binning">
     Binning
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#observation-differences">
     Observation differences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#experimental-variograms">
     Experimental variograms
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#variogram-models">
     Variogram models
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-spherical-model">
       The spherical model
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#exponential-model">
       Exponential model
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gaussian-model">
       Gaussian model
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#matern-model">
       Matérn model
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#when-direction-matters">
   When direction matters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#what-is-direction">
     What is ‘direction’?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-orientiation">
     Defining orientiation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#calculating-orientations">
     Calculating orientations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#directional-variogram">
     Directional variogram
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="variography">
<h1>Variography<a class="headerlink" href="#variography" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-variogram">
<h2>The variogram<a class="headerlink" href="#the-variogram" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general">
<h3>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<p>We start by constructing a random field and sample it. Without knowing about
random field generators, an easy way to go is to stick two trigonometric
functions together and add some noise. There should be clear spatial
correlation apparent.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="gp">In [3]: </span><span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;ggplot&#39;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
</pre></div>
</div>
<p>This field could look like</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># apply the function to a meshgrid and add noise</span>
<span class="gp">In [5]: </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">500</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">500</span><span class="n">j</span><span class="p">]</span>

<span class="gp">In [6]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="go"># generate a regular field</span>
<span class="gp">In [7]: </span><span class="n">_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span>

<span class="go"># add noise</span>
<span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">z</span> <span class="o">=</span> <span class="n">_field</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span>  <span class="mi">500</span><span class="p">))</span>

<span class="gp">In [10]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu_r&#39;</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x7f12c827e748&gt;</span>

<span class="gp">In [11]: </span><span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/tf.png"><img alt="../_images/tf.png" src="../_images/tf.png" style="width: 8in;" /></a>
<div class="section" id="using-scikit-gstat">
<h4>Using scikit-gstat<a class="headerlink" href="#using-scikit-gstat" title="Permalink to this headline">¶</a></h4>
<p>It’s now easy and straightforward to calculate a variogram using
<code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>. We need to sample the field and pass the coordinates and
value to the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="kn">import</span> <span class="nn">skgstat</span> <span class="k">as</span> <span class="nn">skg</span>

<span class="go"># random coordinates</span>
<span class="gp">In [13]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [15]: </span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">Variogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

<span class="gp">In [17]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gh">Out[17]: </span><span class="go">&lt;Figure size 800x500 with 2 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/var1.png"><img alt="../_images/var1.png" src="../_images/var1.png" style="width: 8in;" /></a>
<p>From my personal point of view, there are three main issues with this approach:</p>
<ul class="simple">
<li><p>If one is not an geostatistics expert, one has no idea what he actually did
and can see in the presented figure.</p></li>
<li><p>The figure includes an spatial model, one has no idea if this model is
suitable and fits the observations (wherever they are in the figure)
sufficiently.</p></li>
<li><p>Refer to the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.__init__" title="skgstat.Variogram.__init__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__init__</span></code></a> method of the
Variogram class. There are 10+ arguments that can be set optionally. The
default values will most likely not fit your data and requirements.</p></li>
</ul>
<p>Therefore one will have to understand how the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> works along with some basic
knowledge about variography in oder to be able to properly use <code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>.</p>
<p>However, what we can discuss from the figure, is what a variogram actually is.
At its core it relates a dependent variable to an independent variable and,
in a second step, tries to describe this relationship with a statistical
model. This model on its own describes some of the spatial properties of the
random field and can further be utilized in an interpolation to select nearby
points and weight them based on their statistical properties.</p>
<p>The variogram relates the separating distance between two observation points
to a measure of observation similarity at that given distance. Our expectation
is that variance is increasing with distance, what can basically be seen in
the presented figure.</p>
</div>
</div>
<div class="section" id="distance">
<h3>Distance<a class="headerlink" href="#distance" title="Permalink to this headline">¶</a></h3>
<p>Consider the variogram figure from above, with which an <em>independent</em> and
<em>dependent</em> variable was introduced. In statistics it is common to use
<em>dependent</em> variable as an alias for <em>target variable</em>, because its value is
dependent on the state of the independent variable. In the case of a
variogram, this is the metric of variance on the y-axis. In geostatistics,
the independent variable is usually a measure of Euclidean distance.</p>
<p>Consider observations taken in the environment, it is fairly unlikely to find
two pairs of observations where the separating distance between the
coordinates match exactly the same value. Therefore one has to group all
point pairs at the same distance <em>lag</em> together into one group, or <em>bin</em>.
Beside practicability, there is also another reason, why one would want to
group point pairs at similar separating distances together into one bin.
Consider the plot below, which shows the difference in value over the
distance for all point pair combinations that can be formed for a given sample.
The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> has a function for that:
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.distance_difference_plot" title="skgstat.Variogram.distance_difference_plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_difference_plot</span></code></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [18]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance_difference_plot</span><span class="p">()</span>
<span class="gh">Out[18]: </span><span class="go">&lt;Figure size 800x600 with 1 Axes&gt;</span>

<span class="gp">In [19]: </span><span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/dist_diff_plot.png"><img alt="../_images/dist_diff_plot.png" src="../_images/dist_diff_plot.png" style="width: 8in;" /></a>
<p>While it is possible to see the increasing variability with increasing
distance here quite nicely, it is not possible to guess meaningful moments
for the distributions at different distances. Last but not least, to derive a simple
model as presented in the variogram figure above by the green line, we have
to be able to compress all values at a given distance lag to one estimation
of variance. This would not be possible from the the figure above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are also procedures that can fit a model directly based on unbinned
data. As none of these methods is implemented into <code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>, they
will not be discussed here. If you need them, you are more than welcome
to implement them.</p>
</div>
<p>Binning the separating distances into distance lags is therefore a crucial and
most important task in variogram analysis. The final binning must
discretizise the distance lag at a meaningful resolution at the scale of
interest while still holding enough members in the bin to make valid
estimations. Often this is a trade-off relationship and one has to find a
suitable compromise.</p>
<p>Before diving into binning, we have to understand how the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> handles distance data. The
distance calculation can be controlled by the
<code class="xref py py-func docutils literal notranslate"><span class="pre">dist_func</span></code> argument, which
takes either a string or a function. The default value is <cite>‘euclidean’</cite>.
This value is directly passed down to the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdist</span></code></a> as the <cite>metric</cite> argument.
Consequently, the distance data is stored as a distance matrix for all
input locations passed to <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> on
creation. To be more precise, only the upper triangle is stored
in a <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code></a> with the distance values sorted
row-wise. Consider this very straightforward set of locations:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">locations</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>

<span class="gp">In [21]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">Variogram</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance</span>
<span class="gh">Out[22]: </span><span class="go">array([1.   , 1.414, 1.   , 1.   , 1.414, 1.   ])</span>

<span class="go"># turn into a 2D matrix again</span>
<span class="gp">In [23]: </span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>

<span class="gp">In [24]: </span><span class="nb">print</span><span class="p">(</span><span class="n">squareform</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">distance</span><span class="p">))</span>
<span class="go">[[0.    1.    1.414 1.   ]</span>
<span class="go"> [1.    0.    1.    1.414]</span>
<span class="go"> [1.414 1.    0.    1.   ]</span>
<span class="go"> [1.    1.414 1.    0.   ]]</span>
</pre></div>
</div>
</div>
<div class="section" id="binning">
<h3>Binning<a class="headerlink" href="#binning" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, in real world observation data, there won’t
be two observation location pairs at <strong>exactly</strong> the same distance.
Thus, we need to group information about point pairs at <strong>similar</strong> distance
together, to learn how similar their observed values are.
With a <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a>, we will basically try
to find and describe some systematic statistical behavior from these
similarities. The process of grouping distance data together is
called <em>binning</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code> has many different methods for binning distance data.
They can be set using the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bin_func" title="skgstat.Variogram.bin_func"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin_func</span></code></a>
attribute. You have to pass the name of the method.
The available methods are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.even_width_lags" title="skgstat.binning.even_width_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">even</span></code></a> - evenly spaced bins</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.uniform_count_lags" title="skgstat.binning.uniform_count_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">uniform</span></code></a> - same sample sized bins</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.auto_derived_lags" title="skgstat.binning.auto_derived_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sturges</span></code></a> - derive number of bins by Sturge’s rule</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.auto_derived_lags" title="skgstat.binning.auto_derived_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">scott</span></code></a> - derive number of bins by Scotts’s rule</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.auto_derived_lags" title="skgstat.binning.auto_derived_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt</span></code></a> - derive number of bins by sqaureroot rule</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.auto_derived_lags" title="skgstat.binning.auto_derived_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">doane</span></code></a> - derive number of bins by Doane’s rule</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.auto_derived_lags" title="skgstat.binning.auto_derived_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">fd</span></code></a> - derive number of bins by Freedmann-Diaconis estimator</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.kmeans" title="skgstat.binning.kmeans"><code class="xref py py-func docutils literal notranslate"><span class="pre">kmeans</span></code></a> - derive bins by K-Means clustering</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.ward" title="skgstat.binning.ward"><code class="xref py py-func docutils literal notranslate"><span class="pre">ward</span></code></a> - derive bins by hierachical clustering and Ward’s criterion</p></li>
<li><p><a class="reference internal" href="../reference/binning.html#skgstat.binning.stable_entropy_lags" title="skgstat.binning.stable_entropy_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">stable_entropy</span></code></a> - derive bins from stable entropy setting</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">['even',</span> <span class="pre">'uniform',</span> <span class="pre">'kmeans',</span> <span class="pre">'ward',</span> <span class="pre">'stable_entropy']</span></code> methods will use two parameters
to calculate the bins from the distance matrix: <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a>,
the amount of bins, and <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.maxlag" title="skgstat.Variogram.maxlag"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">maxlag</span></code></a>, the maximum distance lag to be considered.
<code class="docutils literal notranslate"><span class="pre">['sturges',</span> <span class="pre">'scott',</span> <span class="pre">'sqrt',</span> <span class="pre">'fd',</span> <span class="pre">'doane']</span></code> will only use <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.maxlag" title="skgstat.Variogram.maxlag"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">maxlag</span></code></a>
to derive <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a> from statistical properties of the distance matrix.
The <a class="reference internal" href="../reference/binning.html#skgstat.binning.even_width_lags" title="skgstat.binning.even_width_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">even</span></code></a> method will
then form <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a> bins from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.maxlag" title="skgstat.Variogram.maxlag"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">maxlag</span></code></a>
of same width.
The <a class="reference internal" href="../reference/binning.html#skgstat.binning.uniform_count_lags" title="skgstat.binning.uniform_count_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">uniform</span></code></a> method will form the same amount of classes
within the same range, using the same point pair count in each bin.
The following example illustrates this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [25]: </span><span class="kn">from</span> <span class="nn">skgstat.binning</span> <span class="kn">import</span> <span class="n">even_width_lags</span><span class="p">,</span> <span class="n">uniform_count_lags</span>

<span class="gp">In [26]: </span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span>

<span class="gp">In [27]: </span><span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [28]: </span><span class="n">distances</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, look at the different bin edges for the calculated dummy
distance matrix:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [29]: </span><span class="n">even_width_lags</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="gh">Out[29]: </span><span class="go"></span>
<span class="go">(array([ 4.405,  8.809, 13.214, 17.618, 22.023, 26.427, 30.832, 35.237,</span>
<span class="go">        39.641, 44.046]),</span>
<span class="go"> None)</span>

<span class="gp">In [30]: </span><span class="n">uniform_count_lags</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="gh">Out[30]: </span><span class="go"></span>
<span class="go">(array([ 7.198, 10.432, 12.34 , 15.147, 17.693, 20.381, 23.013, 26.278,</span>
<span class="go">        30.641, 44.046]),</span>
<span class="go"> None)</span>
</pre></div>
</div>
<p>Using the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> you can see how the setting
of different binning methods will update the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bins" title="skgstat.Variogram.bins"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">Variogram.bins</span></code></a>
and eventually <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [31]: </span><span class="n">test</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">Variogram</span><span class="p">(</span>
<span class="gp">   ....: </span>    <span class="o">*</span><span class="n">skg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pancake</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">),</span>  <span class="c1"># use some sample data</span>
<span class="gp">   ....: </span>    <span class="n">n_lags</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>                          <span class="c1"># set 25 classes</span>
<span class="gp">   ....: </span>    <span class="n">bin_func</span><span class="o">=</span><span class="s1">&#39;even&#39;</span>
<span class="gp">   ....: </span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [32]: </span><span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>
<span class="go">[ 26.955  53.91   80.865 107.82  134.775 161.73  188.684 215.639 242.594</span>
<span class="go"> 269.549 296.504 323.459 350.414 377.369 404.324 431.279 458.234 485.189</span>
<span class="go"> 512.144 539.099 566.053 593.008 619.963 646.918 673.873]</span>
</pre></div>
</div>
<p>Now, we can easily switch to a method that will derive a new value for <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a>.
That will auto-update <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bins" title="skgstat.Variogram.bins"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">Variogram.bins</span></code></a>
and <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># sqrt will very likely estimate way more bins</span>
<span class="gp">In [33]: </span><span class="n">test</span><span class="o">.</span><span class="n">bin_func</span> <span class="o">=</span> <span class="s1">&#39;sqrt&#39;</span>

<span class="gp">In [34]: </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Auto-derived </span><span class="si">{</span><span class="n">test</span><span class="o">.</span><span class="n">n_lags</span><span class="si">}</span><span class="s1"> bins.&#39;</span><span class="p">)</span>
<span class="go">Auto-derived 354 bins.</span>

<span class="gp">In [35]: </span><span class="nb">print</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>
<span class="go">[0.141 0.283 0.424 0.566 0.707 0.849 0.99  1.131 1.273 1.414]</span>
</pre></div>
</div>
</div>
<div class="section" id="observation-differences">
<h3>Observation differences<a class="headerlink" href="#observation-differences" title="Permalink to this headline">¶</a></h3>
<p>By the term <em>observation differences</em>, the distance between the
observed values are meant. As already layed out, the main idea of
a variogram is to systematially relate similarity of observations
to their spatial proximity. The spatial part was covered in the
sections above, finalized with the calculation of a suitable
binning of all distances. We want to relate exactly these bins
to a measure of similarity of all observation point pairs that
fall into this bin.</p>
<p>That’s basically it. We need to do three more steps to come up
with <em>one</em> value per bin, statistically describing the similarity
at that distance.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Find all point pairs that fall into a bin</p></li>
<li><p>Calculate the <em>distance</em> (difference) of the observed values</p></li>
<li><p>Describe all differences by one number</p></li>
</ol>
</div></blockquote>
<p>Finding all pairs within a bin is straightforward. We already have
the bin edges and all distances between all possible observation
point combinations (stored in the distance matrix). Using the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.spatial.distance.squareform.html#scipy.spatial.distance.squareform" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">squareform</span></code></a> function
of scipy, we <em>could</em> turn the distance matrix into a 2D version.
Then the row and column indices align with the values indices.
However, <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> implements
a method for doing mapping a bit more efficiently.</p>
<p>A <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code></a> of bin groups for each point pair that
is indexed exactly like the <code class="xref py py-func docutils literal notranslate"><span class="pre">distance</span></code>
array can be obtained by <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span></code></a>.</p>
<p>This will be illustrated by some sample data from the <a class="reference internal" href="../reference/data.html#module-skgstat.data" title="skgstat.data"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">data</span></code></a>
submodule.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [36]: </span><span class="n">coords</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pancake</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">)</span>

<span class="gp">In [37]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">Variogram</span><span class="p">(</span>
<span class="gp">   ....: </span>        <span class="n">coords</span><span class="p">,</span>
<span class="gp">   ....: </span>        <span class="n">vals</span><span class="p">,</span>
<span class="gp">   ....: </span>        <span class="n">n_lags</span><span class="o">=</span><span class="mi">25</span>
<span class="gp">   ....: </span>    <span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [38]: </span><span class="n">V</span><span class="o">.</span><span class="n">maxlag</span> <span class="o">=</span> <span class="mi">500</span>
</pre></div>
</div>
<p>Then, you can compare the first 10 point pairs from the distance matrix
to the first 10 elements returned by the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span> <span class="pre">function</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># first 10 distances</span>
<span class="gp">In [39]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[39]: </span><span class="go"></span>
<span class="go">array([179.9,  51. , 151.2, 156.1,  12.8, 162.3, 142.4, 411.8, 156.5,</span>
<span class="go">       257. ])</span>

<span class="go"># first 10 groups</span>
<span class="gp">In [40]: </span><span class="n">V</span><span class="o">.</span><span class="n">lag_groups</span><span class="p">()[:</span><span class="mi">10</span><span class="p">]</span>
<span class="gh">Out[40]: </span><span class="go">array([ 8,  2,  7,  7,  0,  8,  7, 20,  7, 12])</span>
</pre></div>
</div>
<p>Now, we need the actual <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bins" title="skgstat.Variogram.bins"><code class="xref py py-func docutils literal notranslate"><span class="pre">Variogram.bins</span></code></a>
to verify the grouping.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">V</span><span class="o">.</span><span class="n">bins</span>
<span class="gh">Out[41]: </span><span class="go"></span>
<span class="go">array([ 20.,  40.,  60.,  80., 100., 120., 140., 160., 180., 200., 220.,</span>
<span class="go">       240., 260., 280., 300., 320., 340., 360., 380., 400., 420., 440.,</span>
<span class="go">       460., 480., 500.])</span>
</pre></div>
</div>
<p>The elements <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">6,</span> <span class="pre">8]``are</span> <span class="pre">grouped</span> <span class="pre">into</span> <span class="pre">group</span> <span class="pre">``7</span></code>.
Their distance values are <code class="docutils literal notranslate"><span class="pre">[151.2,</span> <span class="pre">156.1,</span> <span class="pre">142.4,</span> <span class="pre">156.5]</span></code>.
The grouping starts with <code class="docutils literal notranslate"><span class="pre">0</span></code>, therefore the corresponding upper bound of the bin
is at index <code class="docutils literal notranslate"><span class="pre">7</span></code> and the lower at <code class="docutils literal notranslate"><span class="pre">6</span></code>.
The bin edges are therefore <code class="docutils literal notranslate"><span class="pre">140.</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">160.</span></code>.
Consequently, the binning and grouping worked fine.</p>
<p>If you want to access all value pairs at a given group, it would of
course be possible to use the machanism above to find the correct points.
However, <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> offers an iterator
that already does that for you:
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_classes" title="skgstat.Variogram.lag_classes"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_classes</span></code></a>. This iterator
will yield all pair-wise observation value differences for the bin
of the actual iteration. The first iteration (index = 0, if you wish)
will yield all differences of group id <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_classes" title="skgstat.Variogram.lag_classes"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_classes</span></code></a> will yield
the difference in value of observation point pairs, not the pairs
themselves.</p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [42]: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">lag_classes</span><span class="p">()):</span>
<span class="gp">   ....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[Group </span><span class="si">%d</span><span class="s1">]: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span>
<span class="gp">   ....: </span>
<span class="go">[Group 0]: 10.36</span>
<span class="go">[Group 1]: 19.10</span>
<span class="go">[Group 2]: 24.20</span>
<span class="go">[Group 3]: 29.70</span>
<span class="go">[Group 4]: 31.24</span>
<span class="go">[Group 5]: 35.21</span>
<span class="go">[Group 6]: 36.84</span>
<span class="go">[Group 7]: 40.44</span>
<span class="go">[Group 8]: 39.32</span>
<span class="go">[Group 9]: 38.65</span>
<span class="go">[Group 10]: 38.36</span>
<span class="go">[Group 11]: 43.47</span>
<span class="go">[Group 12]: 42.45</span>
<span class="go">[Group 13]: 44.85</span>
<span class="go">[Group 14]: 45.26</span>
<span class="go">[Group 15]: 43.83</span>
<span class="go">[Group 16]: 43.36</span>
<span class="go">[Group 17]: 43.98</span>
<span class="go">[Group 18]: 43.80</span>
<span class="go">[Group 19]: 43.74</span>
<span class="go">[Group 20]: 46.80</span>
<span class="go">[Group 21]: 44.70</span>
<span class="go">[Group 22]: 44.65</span>
<span class="go">[Group 23]: 44.49</span>
<span class="go">[Group 24]: 50.13</span>
</pre></div>
</div>
<p>The only thing that is missing for a variogram is that we will not
use the arithmetic mean to describe the realtionship.</p>
</div>
<div class="section" id="experimental-variograms">
<h3>Experimental variograms<a class="headerlink" href="#experimental-variograms" title="Permalink to this headline">¶</a></h3>
<p>The last stage before a variogram function can be modeled is to define
an experimental variogram, also known as <em>empirical variogram</em>, which
will be used to parameterize a variogram model.
However, the expermental variogram already contains a lot of information
about spatial relationships in the data. Therefore, it’s worth looking
at more closely. Last but not least a poor expermental variogram will
also affect the variogram model, which is ultimatively used to interpolate
the input data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In geostatistical literature you can find the terms <em>experimental</em> and
<em>empirical</em> variogram. Both refer to the varigoram estimated from a sample.
In SciKit-GStat the term <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.experimental" title="skgstat.Variogram.experimental"><code class="xref py py-func docutils literal notranslate"><span class="pre">experimental</span></code></a>
variogram is used for the estimated semi-variances solely. Thus, this is a
1D structure (of length <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">n_lags</span></code></a>).
The term <em>empirical</em> (<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.get_empirical" title="skgstat.Variogram.get_empirical"><code class="xref py py-func docutils literal notranslate"><span class="pre">Variogram.get_empirical</span></code></a>)
is used for the combination of <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bins" title="skgstat.Variogram.bins"><code class="xref py py-func docutils literal notranslate"><span class="pre">bins</span></code></a> and
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.experimental" title="skgstat.Variogram.experimental"><code class="xref py py-func docutils literal notranslate"><span class="pre">experimental</span></code></a>, thus it is a tuple of
two 1D arrays.</p>
</div>
<p>The previous sections summarized how distance is calculated and handeled
by the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">class</span></code></a>.
The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span></code></a> function makes it
possible to find corresponding observation value pairs for all distance
lags. Finally the last step will be to use a more suitable estimator
for the similarity of observation values at a specific lag.
In geostatistics this estimator is called semi-variance and the
the most popular estimator is called <em>Matheron estimator</em>.
By default, the <code class="xref py py-func docutils literal notranslate"><span class="pre">Matheron</span></code> estimator will be used.
It is defined as</p>
<div class="math notranslate nohighlight">
\[\gamma (h) = \frac{1}{2N(h)} * \sum_{i=1}^{N(h)}(x)^2\]</div>
<p>with:</p>
<div class="math notranslate nohighlight">
\[x = Z(x_i) - Z(x_{i+h})\]</div>
<p>where <span class="math notranslate nohighlight">\(Z(x_i)\)</span> is the observation value at the i-th location
<span class="math notranslate nohighlight">\(x_i\)</span>. <span class="math notranslate nohighlight">\(h\)</span> is the distance lag and <span class="math notranslate nohighlight">\(N(h)\)</span> is the
number of point pairs at that lag.</p>
<p>You will find more estimators in <code class="xref py py-mod docutils literal notranslate"><span class="pre">skgstat.estimators</span></code>.
There is the <a class="reference internal" href="../reference/estimator.html#skgstat.estimators.cressie" title="skgstat.estimators.cressie"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cressie-Hawkins</span></code></a>,
which is more robust to extreme values. Other so called robust
estimators are <a class="reference internal" href="../reference/estimator.html#skgstat.estimators.dowd" title="skgstat.estimators.dowd"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dowd</span></code></a> or
<a class="reference internal" href="../reference/estimator.html#skgstat.estimators.genton" title="skgstat.estimators.genton"><code class="xref py py-func docutils literal notranslate"><span class="pre">Genton</span></code></a>.
The remaining are experimental estimators and should only be used
with caution.
Let’s compare them directly. You could use the code from the last section
to group the pair-wise value differencens into lag groups and apply the
formula for each estimator. In the example below, we will iteratively change
the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> instance used so far to
achieve this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [43]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">_a</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [44]: </span><span class="n">axes</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="gp">In [45]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.b&#39;</span><span class="p">)</span>
<span class="gh">Out[45]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12c7fe5be0&gt;]</span>

<span class="gp">In [46]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;cressie&#39;</span>

<span class="gp">In [47]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.b&#39;</span><span class="p">)</span>
<span class="gh">Out[47]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12bb763ba8&gt;]</span>

<span class="gp">In [48]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;dowd&#39;</span>

<span class="gp">In [49]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.b&#39;</span><span class="p">)</span>
<span class="gh">Out[49]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12bb763208&gt;]</span>

<span class="gp">In [50]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;semivariance&#39;</span><span class="p">)</span>
<span class="gh">Out[50]: </span><span class="go">Text(0, 0.5, &#39;semivariance&#39;)</span>

<span class="gp">In [51]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Matheron&#39;</span><span class="p">)</span>
<span class="gh">Out[51]: </span><span class="go">Text(0.5, 1.0, &#39;Matheron&#39;)</span>

<span class="gp">In [52]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cressie-Hawkins&#39;</span><span class="p">)</span>
<span class="gh">Out[52]: </span><span class="go">Text(0.5, 1.0, &#39;Cressie-Hawkins&#39;)</span>

<span class="gp">In [53]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Dowd&#39;</span><span class="p">)</span>
<span class="gh">Out[53]: </span><span class="go">Text(0.5, 1.0, &#39;Dowd&#39;)</span>

<span class="gp">In [54]: </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_estimators.png"><img alt="../_images/compare_estimators.png" src="../_images/compare_estimators.png" style="width: 8in;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With this example it is not a good idea to use the Gention estimator,
as it takes a long time to calculate the experimental variogram.</p>
</div>
</div>
<div class="section" id="variogram-models">
<h3>Variogram models<a class="headerlink" href="#variogram-models" title="Permalink to this headline">¶</a></h3>
<p>The last step to describe the spatial pattern in a data set
using variograms is to model the empirically observed and calculated
experimental variogram with a proper mathematical function.
Technically, this setp is straightforward. We need to define a
function that takes a distance value and returns
a semi-variance value. One big advantage of these models is, that we
can assure different things, like positive definitenes. Most models
are also monotonically increasing and approach an upper bound.
Usually these models need three parameters to fit to the experimental
variogram. All three parameters have a meaning and are usefull
to learn something about the data. This upper bound a model approaches
is called <em>sill</em>. The distance at which 95% of the sill are approached
is called the <em>effective range</em>.
That means, the range is the distance at which
observation values do <strong>not</strong> become more dissimilar with increasing
distance. They are statistically independent. That also means, it doesn’t
make any sense to further describe spatial relationships of observations
further apart with means of geostatistics.
The last parameter is the <em>nugget</em>.
It is used to add semi-variance to all values. Graphically that means to
<em>move the variogram up on the y-axis</em>. The nugget is the semi-variance modeled
on the 0-distance lag. Compared to the sill it is the share of variance that
cannot be described spatially.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There is a very important design decision underlying all models in SciKit-GStat.
All models take the <em>effective range</em> as a parameter. If you look into literature,
there is also the <strong>model</strong> parameter <em>range</em>. That can be very confusing, hence
it was decided to fit models on the <em>effective range</em>.
You can translate one into the other quite easily. Transformation factors are
reported in literature, but not commonly the same ones are used.
Finally, the transformation is always coded into SciKit-GStat’s
<code class="xref any docutils literal notranslate"><span class="pre">models</span></code>, even if it’s a 1:1 <em>transformation</em>.</p>
</div>
<div class="section" id="the-spherical-model">
<h4>The spherical model<a class="headerlink" href="#the-spherical-model" title="Permalink to this headline">¶</a></h4>
<p>The sperical model is the most commonly used variogram model.
It is characterized by a very steep, exponential increase in semi-variance.
That means it approaches the sill quite quickly. It can be used when
observations show strong dependency on short distances.
It is defined like:</p>
<div class="math notranslate nohighlight">
\[\gamma = b + C_0 * \left({1.5*\frac{h}{r} - 0.5*\frac{h}{r}^3}\right)\]</div>
<p>if h &lt; r, and</p>
<div class="math notranslate nohighlight">
\[\gamma = b + C_0\]</div>
<p>else. <code class="docutils literal notranslate"><span class="pre">b</span></code> is the nugget, <span class="math notranslate nohighlight">\(C_0\)</span> is the sill, <code class="docutils literal notranslate"><span class="pre">h</span></code> is the input
distance lag and <code class="docutils literal notranslate"><span class="pre">r</span></code> is the effective range. That is the range parameter
described above, that describes the correlation length.
Many other variogram model implementations might define the range parameter,
which is a variogram parameter. This is a bit confusing, as the range parameter
is specific to the used model. Therefore I decided to directly use the
<em>effective range</em> as a parameter, as that makes more sense in my opinion.</p>
<p>As we already calculated an experimental variogram and find the spherical
model in the <code class="xref any docutils literal notranslate"><span class="pre">models</span></code> sub-module, we can utilize e.g.
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">curve_fit</span></code></a> from scipy to fit the model
using a least squares approach.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the given example, the default usage of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="(in SciPy v1.7.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">curve_fit</span></code></a>
will use the Levenberg-Marquardt algorithm, without initial guess for the parameters.
This will fail to find a suitable range parameter.
Thus, for this example, you need to pass an initial guess to the method.</p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="kn">from</span> <span class="nn">skgstat</span> <span class="kn">import</span> <span class="n">models</span>

<span class="go"># set estimator back</span>
<span class="gp">In [56]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;matheron&#39;</span>

<span class="gp">In [57]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span>

<span class="gp">In [58]: </span><span class="n">xdata</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">bins</span>

<span class="gp">In [59]: </span><span class="n">ydata</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">experimental</span>

<span class="gp">In [60]: </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="go"># initial guess - otherwise lm will not find a range</span>
<span class="gp">In [61]: </span><span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>

<span class="gp">In [62]: </span><span class="n">cof</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">spherical</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <em>cof</em> are now the coefficients found to fit the model to the data.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [63]: </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;range: </span><span class="si">%.2f</span><span class="s2">   sill: %.f   nugget: </span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cof</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cof</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cof</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">range: 281.73   sill: 1446   nugget: 101.66</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [64]: </span><span class="n">xi</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>

<span class="gp">In [65]: </span><span class="n">yi</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">spherical</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">cof</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [66]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="s1">&#39;og&#39;</span><span class="p">)</span>
<span class="gh">Out[66]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12bc40cba8&gt;]</span>

<span class="gp">In [67]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/manual_fitted_variogram.png"><img alt="../_images/manual_fitted_variogram.png" src="../_images/manual_fitted_variogram.png" style="width: 8in;" /></a>
<p>The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> does in principle the
same thing. The only difference is that it tries to find a good
initial guess for the parameters and limits the search space for
parameters. That should make the fitting more robust.
Technically, we used the Levenberg-Marquardt algorithm above.
That’s a commonly used, very fast least squares implementation.
However, sometimes it fails to find good parameters, as it is
unbounded and <em>searching</em> an invalid parameter space.
The default for <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> is
Trust-Region Reflective (TRF), which is also the default for
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a>. It uses a valid parameter space as bounds
and therefore won’t fail in finding parameters.
You can, hoever, switch to Levenberg-Marquardt
by setting the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.fit_method" title="skgstat.Variogram.fit_method"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram.fit_method</span></code></a>
to ‘lm’.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [68]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span><span class="s1">&#39;trf&#39;</span>

<span class="gp">In [69]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>

<span class="gp">In [70]: </span><span class="n">pprint</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="go">[263.12497861564043, 1539.0278111437954, 0]</span>

<span class="gp">In [71]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span><span class="s1">&#39;lm&#39;</span>

<span class="gp">In [72]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>

<span class="gp">In [73]: </span><span class="n">pprint</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="go">[263.12045635155715, 1539.023039647012, 0]</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/trf_automatic_fit.png"><img alt="../_images/trf_automatic_fit.png" src="../_images/trf_automatic_fit.png" style="width: 8in;" /></a>
<a class="reference internal image-reference" href="../_images/lm_automatic_fit.png"><img alt="../_images/lm_automatic_fit.png" src="../_images/lm_automatic_fit.png" style="width: 8in;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this example, the fitting method does not make a difference
at all. Generally, you can say that Levenberg-Marquardt is faster
and TRF is more robust.</p>
</div>
</div>
<div class="section" id="exponential-model">
<h4>Exponential model<a class="headerlink" href="#exponential-model" title="Permalink to this headline">¶</a></h4>
<p>The exponential model is quite similar to the spherical one.
It models semi-variance values to increase exponentially with
distance, like the spherical. The main difference is that this
increase is not as steep as for the spherical. That means, the
effective range is larger for an exponential model, that was
parameterized with the same range parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remember that SciKit-GStat uses the <em>effective range</em>
to overcome this confusing behaviour.</p>
</div>
<p>Consequently, the exponential can be used for data that shows a way
too large spatial correlation extent for a spherical model to
capture.</p>
<p>Applied to the data used so far, you can see the difference between
the two models quite nicely:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [75]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spherical&#39;</span><span class="p">)</span>
<span class="gh">Out[75]: </span><span class="go">Text(0.5, 1.0, &#39;Spherical&#39;)</span>

<span class="gp">In [76]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Exponential&#39;</span><span class="p">)</span>
<span class="gh">Out[76]: </span><span class="go">Text(0.5, 1.0, &#39;Exponential&#39;)</span>

<span class="gp">In [77]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="s1">&#39;trf&#39;</span>

<span class="gp">In [78]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[78]: </span><span class="go">&lt;Figure size 800x400 with 2 Axes&gt;</span>

<span class="go"># switch the model</span>
<span class="gp">In [79]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;exponential&#39;</span>

<span class="gp">In [80]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_spherical_exponential.png"><img alt="../_images/compare_spherical_exponential.png" src="../_images/compare_spherical_exponential.png" style="width: 8in;" /></a>
<p>Keep in mind how important the theoretical model is. We will
use it for interpolation later on and the quality of this interpolation
will primarily rely on the fit of the model to the experimental data
smaller than the effective range.
From the example above it is quite hard to tell, which is the correct one.
Also, the goodness of fit is quite comparable:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># spherical</span>
<span class="gp">In [81]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span>

<span class="gp">In [82]: </span><span class="n">rmse_sph</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">rmse</span>

<span class="gp">In [83]: </span><span class="n">r_sph</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;effective_range&#39;</span><span class="p">)</span>

<span class="go"># exponential</span>
<span class="gp">In [84]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;exponential&#39;</span>

<span class="gp">In [85]: </span><span class="n">rmse_exp</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">rmse</span>

<span class="gp">In [86]: </span><span class="n">r_exp</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;effective_range&#39;</span><span class="p">)</span>

<span class="gp">In [87]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Spherical   RMSE: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rmse_sph</span><span class="p">)</span>
<span class="go">Spherical   RMSE: 114.70</span>

<span class="gp">In [88]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exponential RMSE: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rmse_exp</span><span class="p">)</span>
<span class="go">Exponential RMSE: 104.83</span>
</pre></div>
</div>
<p>But the difference in effective range is more pronounced:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [89]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Spherical effective range:    </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">r_sph</span><span class="p">)</span>
<span class="go">Spherical effective range:    263.1</span>

<span class="gp">In [90]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exponential effective range:  </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">r_exp</span><span class="p">)</span>
<span class="go">Exponential effective range:  363.3</span>
</pre></div>
</div>
<p>Finally, we can use both models to perform a Kriging interpolation.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [91]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="gp">In [92]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span>

<span class="gp">In [93]: </span><span class="n">krige1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">to_gs_krige</span><span class="p">()</span>

<span class="gp">In [94]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;exponential&#39;</span>

<span class="gp">In [95]: </span><span class="n">krige2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">to_gs_krige</span><span class="p">()</span>

<span class="go"># build a grid</span>
<span class="gp">In [96]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="go"># apply</span>
<span class="gp">In [97]: </span><span class="n">field1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">krige1</span><span class="o">.</span><span class="n">structured</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="gp">In [98]: </span><span class="n">field2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">krige2</span><span class="o">.</span><span class="n">structured</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="go"># use the same bounds</span>
<span class="gp">In [99]: </span><span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">))</span>

<span class="gp">In [100]: </span><span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">))</span>

<span class="go"># plot</span>
<span class="gp">In [101]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spherical&#39;</span><span class="p">)</span>
<span class="gh">Out[101]: </span><span class="go">Text(0.5, 1.0, &#39;Spherical&#39;)</span>

<span class="gp">In [102]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Exponential&#39;</span><span class="p">)</span>
<span class="gh">Out[102]: </span><span class="go">Text(0.5, 1.0, &#39;Exponential&#39;)</span>

<span class="gp">In [103]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">field1</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;terrain_r&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
<span class="gh">Out[103]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x7f13068733c8&gt;</span>

<span class="gp">In [104]: </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">field2</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;terrain_r&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
<span class="gh">Out[104]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x7f12bc377198&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/model_compare_kriging.png"><img alt="../_images/model_compare_kriging.png" src="../_images/model_compare_kriging.png" style="width: 8in;" /></a>
<p>While the two final maps look alike, in the difference plot, you can
spot some differences. While performing an analysis, with the model functions in mind,
you should take these differences and add them as uncertainty cause by model choice to
your final result.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># calculate the differences</span>
<span class="gp">In [105]: </span><span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">field2</span> <span class="o">-</span> <span class="n">field1</span><span class="p">)</span>

<span class="gp">In [106]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean difference:     </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
<span class="go">Mean difference:     1.0</span>

<span class="gp">In [107]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;3rd quartile diffs.: </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
<span class="go">3rd quartile diffs.: 1.4</span>

<span class="gp">In [108]: </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max differences:     </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
<span class="go">Max differences:     9.9</span>

<span class="gp">In [109]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;hot&#39;</span><span class="p">)</span>
<span class="gh">Out[109]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x7f12c7ff5f98&gt;</span>

<span class="gp">In [110]: </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="gh">Out[110]: </span><span class="go">&lt;matplotlib.colorbar.Colorbar at 0x7f12c8318be0&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/model_compare_kriging_diff.png"><img alt="../_images/model_compare_kriging_diff.png" src="../_images/model_compare_kriging_diff.png" style="width: 6in;" /></a>
</div>
<div class="section" id="gaussian-model">
<h4>Gaussian model<a class="headerlink" href="#gaussian-model" title="Permalink to this headline">¶</a></h4>
<p>The last fundamental variogram model is the Gaussian.
Unlike the spherical and exponential it models a very different
spatial relationship between semi-variance and distance.
Following the Gaussian model, observations are assumed to
be similar up to intermediate distances, showing just a
gentle increase in semi-variance. Then, the semi-variance
increases dramatically wihtin just a few distance units up
to the sill, which is again approached asymtotically.
The model can be used to simulate very sudden and sharp
changes in the variable at a specific distance,
while being very similar at smaller distances.</p>
<p>To show a typical Gaussian model, we will load another
sample dataset, that actually shows a Gaussian experimental variogram.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [111]: </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="gp">In [112]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/sample_lr.csv&#39;</span><span class="p">)</span>

<span class="gp">In [113]: </span><span class="n">Vg</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">Variogram</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span> <span class="n">data</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   .....: </span>    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [114]: </span><span class="n">Vg</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_data_gaussian_model.png"><img alt="../_images/sample_data_gaussian_model.png" src="../_images/sample_data_gaussian_model.png" style="width: 8in;" /></a>
</div>
<div class="section" id="matern-model">
<h4>Matérn model<a class="headerlink" href="#matern-model" title="Permalink to this headline">¶</a></h4>
<p>Another, quite powerful model is the Matérn model.
Especially in cases where you cannot chose the appropiate model a priori so easily.
The Matérn model takes an additional smoothness paramter, that can
change the shape of the function in between an exponential
model shape and a Gaussian one.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [115]: </span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="go"># plot a exponential and a gaussian</span>
<span class="gp">In [116]: </span><span class="n">y_exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [117]: </span><span class="n">y_gau</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [118]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="gp">In [119]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y_exp</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exponential&#39;</span><span class="p">)</span>
<span class="gh">Out[119]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12c5ed3da0&gt;]</span>

<span class="gp">In [120]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y_gau</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="gh">Out[120]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12bb580b00&gt;]</span>

<span class="gp">In [121]: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">matern</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>
<span class="gp">   .....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;--k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;matern s=</span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [122]: </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="gh">Out[122]: </span><span class="go">&lt;matplotlib.legend.Legend at 0x7f12bc428e10&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_smoothness_parameter_matern.png"><img alt="../_images/compare_smoothness_parameter_matern.png" src="../_images/compare_smoothness_parameter_matern.png" style="width: 8in;" /></a>
<p>This example illustrates really nicely, how the smoothness parameter adapts the Matérn
model shape.
Moreover, the smoothness parameter can be used to assess whether an experimental
variogram is rather showing a Gaussian or exponential behavior.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you would like to export a Variogram instance to gstools, the smoothness parameter
may not be smaller than <code class="docutils literal notranslate"><span class="pre">0.2</span></code>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="when-direction-matters">
<h2>When direction matters<a class="headerlink" href="#when-direction-matters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-direction">
<h3>What is ‘direction’?<a class="headerlink" href="#what-is-direction" title="Permalink to this headline">¶</a></h3>
<p>The classic approach to calculate a variogram is based on the
assumption that covariance between observations can be related to
their separating distance. For this, point pairs of all observation
points are formed and it is assumed that they can be formed without any restriction.
The only paramter to be influenced is a limiting distance, beyond which
a point pair does not make sense anymore.</p>
<p>This assumption might not always hold. Especially in landscapes, processes do
not occur randomly, but in an organized manner. This organization is often
directed, which can lead to stronger covariance in one direction than another.
Therefore, another step has to be introduced before lag classes are formed.</p>
<p>The <em>direction</em> of a variogram is then a orientation, which two points need.
If they are not oriented in the specified way, they will be ignored while calculating
a semi-variance value for a given lag class. Usually, you will specify a
orientation, which is called <a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram.azimuth" title="skgstat.DirectionalVariogram.azimuth"><code class="xref py py-func docutils literal notranslate"><span class="pre">azimuth</span></code></a>,
and a <a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram.tolerance" title="skgstat.DirectionalVariogram.tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">tolerance</span></code></a>, which is an
offset from the given azimuth, at which a point pair will still be accepted.</p>
</div>
<div class="section" id="defining-orientiation">
<h3>Defining orientiation<a class="headerlink" href="#defining-orientiation" title="Permalink to this headline">¶</a></h3>
<p>One has to decide how orientation of two points is determined. In scikit-gstat,
orientation between two observation points is only defined in <span class="math notranslate nohighlight">\(\mathbb{R}^2\)</span>.
We define the orientation as the <strong>angle between the vector connecting two observation points
with the x-axis</strong>.</p>
<p>Thus, also the <a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram.azimuth" title="skgstat.DirectionalVariogram.azimuth"><code class="xref py py-func docutils literal notranslate"><span class="pre">azimuth</span></code></a> is defined as an
angle of the azimutal vector to the x-axis, with an
<a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram.tolerance" title="skgstat.DirectionalVariogram.tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">tolerance</span></code></a> in degrees added to the
exact azimutal orientation clockwise and counter clockwise.</p>
<p>The angle <span class="math notranslate nohighlight">\(\Phi\)</span> between two vetors <code class="docutils literal notranslate"><span class="pre">u,v</span></code> is given like:</p>
<div class="math notranslate nohighlight">
\[\Phi = cos^{-1}\left(\frac{u \circ v}{||u|| \cdot ||v||}\right)\]</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [123]: </span><span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">FancyArrowPatch</span> <span class="k">as</span> <span class="n">farrow</span>

<span class="gp">In [124]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

<span class="gp">In [125]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[125]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7f12bb646518&gt;</span>

<span class="gp">In [126]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[126]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7f12bb67dcf8&gt;</span>

<span class="gp">In [127]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[127]: </span><span class="go">(-0.1, 3.0)</span>

<span class="gp">In [128]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="gh">Out[128]: </span><span class="go">(-0.1, 2.0)</span>

<span class="gp">In [129]: </span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[129]: </span><span class="go">&lt;matplotlib.collections.PathCollection at 0x7f12bb60d240&gt;</span>

<span class="gp">In [130]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;A (0, 0)&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">.0</span><span class="p">,</span> <span class="mf">.26</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="gh">Out[130]: </span><span class="go">Text(0.0, 0.26, &#39;A (0, 0)&#39;)</span>

<span class="gp">In [131]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;B (2, 1)&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.05</span><span class="p">,</span><span class="mf">1.05</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="gh">Out[131]: </span><span class="go">Text(2.05, 1.05, &#39;B (2, 1)&#39;)</span>

<span class="gp">In [132]: </span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;Simple,head_width=6,head_length=12,tail_width=1&quot;</span>

<span class="gp">In [133]: </span><span class="n">ar</span> <span class="o">=</span> <span class="n">farrow</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3, rad=.2&quot;</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="n">arrowstyle</span><span class="p">)</span>

<span class="gp">In [134]: </span><span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
<span class="gh">Out[134]: </span><span class="go">&lt;matplotlib.patches.FancyArrowPatch at 0x7f12bb60d978&gt;</span>

<span class="gp">In [135]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;26.5°&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[135]: </span><span class="go">Text(1.5, 0.25, &#39;26.5°&#39;)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_orientation_of_2_1.png"><img alt="../_images/sample_orientation_of_2_1.png" src="../_images/sample_orientation_of_2_1.png" style="width: 6in;" /></a>
<p>The described definition of orientation is illustrated in the figure above.
There are two observation points, <span class="math notranslate nohighlight">\(A (0,0)\)</span> and <span class="math notranslate nohighlight">\(B (2, 1)\)</span>. To decide
wether to account for them when calculating the semi-variance at their separating
distance lag, their orientation is used. Only if the direction of the varigram includes
this orientation, the points are used. Imagine the azimuth and tolerance would be
<code class="docutils literal notranslate"><span class="pre">45°</span></code>, then anything between <code class="docutils literal notranslate"><span class="pre">0°</span></code> (East) and <code class="docutils literal notranslate"><span class="pre">90°</span></code> orientation would be included.
The given example shows the orientation angle <span class="math notranslate nohighlight">\(\Phi = 26.5°\)</span>, which means the
vector <span class="math notranslate nohighlight">\(\overrightarrow{AB}\)</span> is included.</p>
</div>
<div class="section" id="calculating-orientations">
<h3>Calculating orientations<a class="headerlink" href="#calculating-orientations" title="Permalink to this headline">¶</a></h3>
<p>SciKit-GStat implements a slightly adaped version of the formula given in the
last section. It makes use of symmetric search areas (tolerance is applied clockwise
and counter clockwise) und therefore any calculated angle might be the result
of calculating the orientation of <span class="math notranslate nohighlight">\(\overrightarrow{AB}\)</span> or
<span class="math notranslate nohighlight">\(\overrightarrow{BA}\)</span>. Mathematically, these two vectors have two different
angles, but they are always both taken into account or omitted for a variagram
at the same time. Thus, it does not make a difference for variography.
However, it does make a difference when you try to use the orientation angles
directly as the containing matrix can contain the inverse angles.</p>
<p>This can be demonstrated by an easy example. Let <code class="docutils literal notranslate"><span class="pre">c</span></code> be a set of points mirrored
along the x-axis.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [136]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="gp">In [137]: </span><span class="n">east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>We can plug these two arrays into the the formula above:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [138]: </span><span class="n">u</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>   <span class="c1"># omit the first one</span>

<span class="gp">In [139]: </span><span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">east</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>

<span class="gp">In [140]: </span><span class="n">angles</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[140]: </span><span class="go">array([26.6, 63.4, 26.6, 63.4])</span>
</pre></div>
</div>
<p>You can see, that the both points and their mirrored counterpart have the same
angle to the x-axis, just like expected. This can be visualized by the plot below:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [141]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

<span class="gp">In [142]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">2.25</span><span class="p">)</span>
<span class="gh">Out[142]: </span><span class="go">(-0.1, 2.25)</span>

<span class="gp">In [143]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span><span class="mf">2.1</span><span class="p">)</span>
<span class="gh">Out[143]: </span><span class="go">(-2.1, 2.1)</span>

<span class="gp">In [144]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[144]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7f12b80c0860&gt;</span>

<span class="gp">In [145]: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.1f</span><span class="s1">°&#39;</span> <span class="o">%</span> <span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [146]: </span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[146]: </span><span class="go">&lt;matplotlib.collections.PathCollection at 0x7f12b80c0c50&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_orientation_of_multiple_points.png"><img alt="../_images/sample_orientation_of_multiple_points.png" src="../_images/sample_orientation_of_multiple_points.png" style="width: 6in;" /></a>
<p>The main difference to the internal structure storing the orientation angles for a
<a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram" title="skgstat.DirectionalVariogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectionalVariogram</span></code></a> instance will store different
angles.
To use the class on only five points, we need to prevent the class from fitting, as
fitting on only 5 points will not work. But this does not affect the orientation calculations.
Therefore, the <code class="xref py py-func docutils literal notranslate"><span class="pre">fit</span></code> mehtod is overwritten.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [147]: </span><span class="k">class</span> <span class="nc">TestCls</span><span class="p">(</span><span class="n">skg</span><span class="o">.</span><span class="n">DirectionalVariogram</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">   .....: </span>        <span class="k">pass</span>
<span class="gp">   .....: </span>

<span class="gp">In [148]: </span><span class="n">DV</span> <span class="o">=</span> <span class="n">TestCls</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>

<span class="gp">In [149]: </span><span class="n">DV</span><span class="o">.</span><span class="n">_calc_direction_mask_data</span><span class="p">()</span>

<span class="gp">In [150]: </span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">DV</span><span class="o">.</span><span class="n">_angles</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="gh">Out[150]: </span><span class="go">array([ 26.565,  63.435, 333.435, 296.565])</span>
</pre></div>
</div>
<p>The first two points (with positive y-coordinate) show the same result. The other two,
with negative y-coordinates, are also calculated counter clockwise:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [151]: </span><span class="mi">360</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">DV</span><span class="o">.</span><span class="n">_angles</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[151]: </span><span class="go">array([26.565, 63.435])</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram" title="skgstat.DirectionalVariogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectionalVariogram</span></code></a> class has a plotting
function to show a network graph of all point pairs that are oriented in the
variogram direction. But first we need to increase the tolerance as half tolerance
(<code class="docutils literal notranslate"><span class="pre">45°</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">22.5°</span></code> clockwise and counter clockwise) is smaller than both orientations.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [152]: </span><span class="n">DV</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="mi">90</span>

<span class="gp">In [153]: </span><span class="n">DV</span><span class="o">.</span><span class="n">pair_field</span><span class="p">()</span>
<span class="gh">Out[153]: </span><span class="go">&lt;Figure size 800x800 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_pair_field_plot.png"><img alt="../_images/sample_pair_field_plot.png" src="../_images/sample_pair_field_plot.png" style="width: 8in;" /></a>
</div>
<div class="section" id="directional-variogram">
<h3>Directional variogram<a class="headerlink" href="#directional-variogram" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [154]: </span><span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;data/aniso_x2.txt&#39;</span><span class="p">)</span>

<span class="gp">In [155]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1312</span><span class="p">)</span>

<span class="gp">In [156]: </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="gp">In [157]: </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
</pre></div>
</div>
<p>The next step is to create two different variogram instances, which share the same
parameters, but use a different azimuth angle. One oriented to North and the
second one oriented to East.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [158]: </span><span class="n">Vnorth</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">DirectionalVariogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">azimuth</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [159]: </span><span class="n">Veast</span> <span class="o">=</span> <span class="n">skg</span><span class="o">.</span><span class="n">DirectionalVariogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [160]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;north&#39;</span><span class="p">:</span><span class="n">Vnorth</span><span class="o">.</span><span class="n">describe</span><span class="p">(),</span> <span class="s1">&#39;east&#39;</span><span class="p">:</span> <span class="n">Veast</span><span class="o">.</span><span class="n">describe</span><span class="p">()})</span>
<span class="gh">Out[160]: </span><span class="go"></span>
<span class="go">                                                                        north                                               east</span>
<span class="go">model                                                               spherical                                          spherical</span>
<span class="go">estimator                                                            matheron                                           matheron</span>
<span class="go">dist_func                                                           euclidean                                          euclidean</span>
<span class="go">normalized_effective_range                                               6400                                            2933.08</span>
<span class="go">normalized_sill                                                       2.84452                                           0.810282</span>
<span class="go">normalized_nugget                                                           0                                                  0</span>
<span class="go">effective_range                                                            80                                            36.6635</span>
<span class="go">sill                                                                    1.483                                           0.808277</span>
<span class="go">nugget                                                                      0                                                  0</span>
<span class="go">params                      {&#39;estimator&#39;: &#39;matheron&#39;, &#39;model&#39;: &#39;spherical&#39;...  {&#39;estimator&#39;: &#39;matheron&#39;, &#39;model&#39;: &#39;spherical&#39;...</span>
<span class="go">kwargs                                                                     {}                                                 {}</span>
</pre></div>
</div>
<p>You can see, how the two are differing in effective range and also sill, only
caused by the orientation. Let’s look at the experimental variogram:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [161]: </span><span class="n">fix</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="gp">In [162]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Vnorth</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">Vnorth</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.--r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;North-South&#39;</span><span class="p">)</span>
<span class="gh">Out[162]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12b80c04e0&gt;]</span>

<span class="gp">In [163]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Veast</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">Veast</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.--b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;East-West&#39;</span><span class="p">)</span>
<span class="gh">Out[163]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7f12b80de940&gt;]</span>

<span class="gp">In [164]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;lag [m]&#39;</span><span class="p">)</span>
<span class="gh">Out[164]: </span><span class="go">Text(0.5, 0, &#39;lag [m]&#39;)</span>

<span class="gp">In [165]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;semi-variance (matheron)&#39;</span><span class="p">)</span>
<span class="gh">Out[165]: </span><span class="go">Text(0, 0.5, &#39;semi-variance (matheron)&#39;)</span>

<span class="gp">In [166]: </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
<span class="gh">Out[166]: </span><span class="go">&lt;matplotlib.legend.Legend at 0x7f12b803f7f0&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/expermiental_direcional_varigram_comparison.png"><img alt="../_images/expermiental_direcional_varigram_comparison.png" src="../_images/expermiental_direcional_varigram_comparison.png" style="width: 8in;" /></a>
<p>The shape of both experimental variograms is very similar on the first 40 meters
of distance. Within this range, the apparent anisotropy is not pronounced.
The East-West oriented variograms also have an effective range of only about 40 meters,
which means that in this direction the observations become statistically independent
at larger distances.
For the North-South variogram the effective range is way bigger and the variogram
plot reveals much larger correlation lengths in that direction. The spatial
dependency is thus directed in North-South direction.</p>
<p>To perform Kriging, you would now transform the data, especially in North-West
direction, unitl both variograms look the same within the effective range.
Finally, the Kriging result is back-transformed into the original coordinate system.</p>
</div>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="introduction.html" title="previous page">Introduction</a>
    <a class='right-next' id="next-link" href="kriging.html" title="next page">Interpolation</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, Mirko Mälicke.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>